# 项目文件描述


- core/decision.py: 决策环境模块，用于分析用户需求类型并确定处理流程。包含DecisionProcess类和DecisionResult数据类，能够判断需求是否需要修改代码，为AI助手提供决策工具。

- examples/example_workflow.py: WorkflowEngine使用示例，演示如何配置和初始化工作流引擎处理用户需求。创建WorkflowEngineConfig配置，设置项目目录、模型参数等，调用process_requirement方法处理需求。作为框架使用的入门示例。

- examples/example_code_generate.py: 代码生成流程示例，展示如何使用CodeEngineer处理代码修改需求。演示了从需求分析到代码生成和提交的完整流程，包含main函数作为入口点。

- examples/example_chat_process.py: 聊天处理流程示例，展示如何使用ChatProcessor处理用户对话需求。与代码生成示例不同，不使用版本管理，主要演示如何回答用户关于项目的问题。

- examples/advanced/custom_workflow.py: 自定义工作流处理程序，展示如何将bella-issues-bot集成到自定义应用中。包含preprocess_requirement和postprocess_response两个关键函数，分别用于需求预处理和响应后处理。主程序读取需求文件、进行预处理、调用run_workflow执行工作流，最后进行后处理。


# 文件内容



```
File: core/decision.py
1 """
2 决策环境模块，用于分析用户需求类型并确定处理流程。
3 
4 该模块主要功能：
5 1. 分析用户输入的需求是否需要修改代码
6 2. 根据分析结果决定使用代码修改流程还是对话流程
7 3. 为AI助手提供决策工具
8 """
9 
10 from dataclasses import dataclass
11 from typing import Optional
12 
13 from langchain_core.tools import StructuredTool
14 from pydantic import BaseModel, Field
15 
16 from core.ai import AIAssistant, AIConfig
17 from core.log_config import get_logger
18 from core.version_manager import VersionManager
19 
20 logger = get_logger(__name__)
21 
22 @dataclass
23 class DecisionResult:
24     """存储决策结果信息"""
25     needs_code_modification: bool
26     reasoning: str
27 
28 
29 class DecisionProcess:
30     """
31     决策环境类，用于确定用户需求是代码修改还是对话
32     """
33     
34     def __init__(self, ai_config: AIConfig, version_manager: VersionManager):
35         """
36         初始化决策环境
37         
38         Args:
39             ai_config: AI配置信息
40             version_manager: 版本管理器实例
41         """
42         self.version_manager = version_manager
43         self.ai_assistant = AIAssistant(
44             config=ai_config, 
45             tools=[self._create_requirement_analyzer_tool()]
46         )
47 
48     def analyze_requirement(self, user_requirement: str) -> DecisionResult:
49         """
50         分析用户需求类型
51         
52         Args:
53             user_requirement: 用户输入的需求
54             
55         Returns:
56             DecisionResult: 决策结果
57         """
58         # 只有当轮次大于1时，才需要进行决策分析
59         if self.version_manager.current_round_num <= 1:
60             # 首轮默认是代码修改需求
61             return DecisionResult(
62                 needs_code_modification=True,
63                 reasoning="首轮交互默认为代码修改需求"
64             )
65 
66         # 获取历史上下文
67         history_context = self.version_manager.get_formatted_history()
68         
69         # 构建提示词
70         prompt = f"""
71 # 任务
72 你需要分析用户的需求是否需要修改项目文件，如代码或文档，还是只需要回答问题。
73 
74 # 历史上下文
75 {history_context}
76 
77 # 当前用户需求
78 {user_requirement}
79 
80 # 决策步骤
81 1. 仔细阅读用户当前的需求
82 2. 分析需求是否包含代码修改、文档修改、新增功能、修复bug、回滚代码等要求
83 3. 如果用户只是提问、咨询、请求解释或澄清，则判断为不需要修改代码
84 4、只要需要修改项目中的文件，则判断为需要修改代码
85 
86 请使用requirement_analyzer工具返回决策结果。
87 """
88 
89         # 发送给AI进行分析
90         response = self.ai_assistant.generate_response(prompt, use_tools=True)
91         
92         # 如果没有得到有效决策，默认为需要修改代码
93         if not isinstance(response, dict) or 'needs_code_modification' not in response:
94             logger.warning("未获取到有效决策结果，默认为需要修改代码")
95             return DecisionResult(
96                 needs_code_modification=True,
97                 reasoning="无法确定需求类型，默认为代码修改"
98             )
99             
100         return DecisionResult(
101             needs_code_modification=response['needs_code_modification'],
102             reasoning=response['reasoning']
103         )
104 
105     class _RequirementAnalyzerSchema(BaseModel):
106         needs_code_modification: bool = Field(..., description="是否需要修改项目文件，如代码或文档")
107         reasoning: Optional[str] = Field(None, description="决策理由")
108 
109     def _create_requirement_analyzer_tool(self) -> StructuredTool:
110         """创建需求分析工具"""
111         return StructuredTool.from_function(
112             name="requirement_analyzer",
113             description="分析用户需求是否需要修改项目文件，如代码或文档的工具",
114             func=lambda **kwargs: kwargs,
115             args_schema=self._RequirementAnalyzerSchema,
116             return_direct=True
117         )
118
```




```
File: examples/example_workflow.py
1 """
2 这个示例展示如何使用WorkflowEngine处理用户需求，自动决策是代码生成还是对话流程
3 """
4 import logging
5 import os
6 
7 from dotenv import load_dotenv
8 
9 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
10 from core.log_config import setup_logging
11 
12 
13 def main():
14     setup_logging(log_level=logging.DEBUG)
15     # 加载环境变量
16     load_dotenv()
17     
18     # 创建工作目录
19     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
20     issue_id = 5
21     
22     # 创建工作流引擎配置
23     config = WorkflowEngineConfig(
24         project_dir=project_dir,
25         issue_id=issue_id,
26         core_model="coder-model",
27         data_model="gpt-4o",
28         core_template=1,
29         data_template=0.7,
30         default_branch="dev"
31     )
32     
33     # 初始化工作流引擎
34     workflow_engine = WorkflowEngine(config)
35 
36     requirement = """
37     分析项目的所有代码。把项目的Read.me进行完善。尤其是未完成的。
38     """
39     
40     # 处理代码修改需求
41     workflow_engine.process_requirement(requirement)
42 
43 if __name__ == "__main__":
44     main()
45
```




```
File: examples/example_code_generate.py
1 import logging
2 import os
3 
4 from dotenv import load_dotenv
5 
6 from core.ai import AIConfig
7 from core.code_engineer import CodeEngineerConfig, CodeEngineer
8 from core.diff import Diff
9 from core.file_memory import FileMemory, FileMemoryConfig
10 from core.file_selector import FileSelector
11 from core.git_manager import GitManager, GitConfig
12 from core.log_config import setup_logging
13 from core.log_manager import LogManager, LogConfig
14 from core.prompt_generator import PromptGenerator, PromptData
15 from core.version_manager import VersionManager
16 
17 
18 def main():
19     setup_logging(log_level=logging.DEBUG)
20     # 加载环境变量
21     load_dotenv()
22     
23     # 创建工作目录
24     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
25 
26     issue_id = 3
27     
28     # 初始化日志管理器
29     log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)
30     log_manager = LogManager(config=log_config)
31     current_round = log_manager.get_current_round()
32 
33     
34     # 初始化Git管理器
35     git_config = GitConfig(
36         repo_path=project_dir
37     )
38     git_manager = GitManager(config=git_config)
39     
40     # 初始化AI助手
41     ai_config = AIConfig(
42         model_name="coder-model",
43         temperature=1
44     )
45     
46     # 初始化版本管理器
47     version_manager = VersionManager(issue_id=issue_id, log_manager=log_manager, git_manager=git_manager, ai_config=ai_config)
48 
49     current_requirement = '''
50     将 example_chat_process.py 和 example_code_generate.py的流程整合到 workflow_engine.py 中，目前两个代码文件都是写代码和回复用户的完整流程。
51     使用DecisionEnvironment来决策选择何种模式。
52     '''
53     requirement, history = version_manager.ensure_version_and_generate_context(current_requirement)
54 
55     if current_round > 1:
56         file_memory = FileMemory(config=FileMemoryConfig(git_manager=git_manager, ai_config=ai_config, project_dir=project_dir))
57         file_memory.update_file_details()
58 
59     selector = FileSelector(
60         project_dir,
61         issue_id,
62         ai_config=ai_config,
63     )
64 
65     files = selector.select_files_for_requirement(requirement)
66 
67     descriptions = FileMemory.get_selected_file_descriptions(project_dir, files)
68 
69     data = PromptData(requirement=requirement, project_dir=project_dir, steps = history, files=files, file_desc=descriptions)
70     user_prompt = PromptGenerator.generatePrompt(data)
71     config = CodeEngineerConfig(project_dir=project_dir, ai_config=ai_config)
72 
73     engineer = CodeEngineer(config, LogManager(LogConfig(project_dir=project_dir, issue_id=issue_id)), Diff(AIConfig(temperature=0.1,
74                                                                                                               model_name="gpt-4o")))
75     engineer.process_prompt(prompt=user_prompt)
76 
77 
78 if __name__ == "__main__":
79     main()
80
```




```
File: examples/example_chat_process.py
1 """
2 这个示例展示如何使用ChatProcessor处理用户对话需求
3 与example_generate.py不同之处在于：
4 1. 不需要使用版本管理
5 2. 使用ChatProcessor替代CodeEngineer
6 """
7 import logging
8 import os
9 
10 from dotenv import load_dotenv
11 
12 from core.ai import AIConfig
13 from core.chat_processor import ChatProcessor, ChatProcessorConfig
14 from core.file_memory import FileMemory, FileMemoryConfig
15 from core.file_selector import FileSelector
16 from core.git_manager import GitManager, GitConfig
17 from core.log_config import setup_logging
18 from core.log_manager import LogManager, LogConfig
19 
20 
21 def main():
22     setup_logging(log_level=logging.DEBUG)
23     # 加载环境变量
24     load_dotenv()
25     
26     # 创建工作目录
27     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
28 
29     issue_id = 5  # 使用一个新的issue_id
30     
31     # 初始化日志管理器
32     log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)
33     log_manager = LogManager(config=log_config)
34     current_round = log_manager.get_current_round()
35 
36     
37     # 初始化Git管理器
38     git_config = GitConfig(
39         repo_path=project_dir
40     )
41     git_manager = GitManager(config=git_config)
42 
43     
44     # 初始化AI助手
45     ai_config = AIConfig(
46         model_name="coder-model",
47         temperature=1
48     )
49     
50     current_requirement = '''
51     请详细解释下工作流引擎(workflow_engine)在本项目中的作用，以及它是如何协调各个组件工作的
52     '''
53 
54     if current_round > 1:
55         file_memory = FileMemory(config=FileMemoryConfig(git_manager=git_manager, ai_config=ai_config, project_dir=project_dir))
56         file_memory.update_file_details()
57 
58     selector = FileSelector(
59         project_dir,
60         issue_id,
61         ai_config=ai_config,
62     )
63 
64     # 选择相关文件来提供上下文
65     files = selector.select_files_for_requirement(current_requirement)
66     descriptions = FileMemory.get_selected_file_descriptions(project_dir, files)
67 
68     # 使用ChatProcessor处理用户请求
69     chat_config = ChatProcessorConfig(
70         system_prompt="你是一个项目助手，负责回答关于代码库的问题。下面会给出用户的问题以及相关的项目文件信息。"
71     )
72     chat_processor = ChatProcessor(ai_config=ai_config, log_manager=log_manager, config=chat_config)
73     
74     chat_processor.process_chat(current_requirement)
75 
76 
77 if __name__ == "__main__":
78     main()
79
```




```
File: examples/advanced/custom_workflow.py
1 """
2 高级示例：自定义工作流处理程序
3 
4 展示如何将bella-issues-bot集成到自定义应用程序中，
5 包括自定义前处理和后处理逻辑。
6 """
7 
8 import os
9 from typing import Optional
10 from client.runner import run_workflow
11 
12 
13 def preprocess_requirement(raw_requirement: str) -> str:
14     """
15     预处理用户需求，增加额外的上下文信息
16     
17     Args:
18         raw_requirement: 原始需求文本
19         
20     Returns:
21         增强后的需求文本
22     """
23     # 例如：添加项目特定的规范或约束
24     return f"{raw_requirement}\n\n注意：请确保代码遵循PEP 8规范，并包含适当的单元测试。"
25 
26 
27 def postprocess_response(response: str) -> str:
28     """
29     处理AI响应，进行后期格式化或额外操作
30     
31     Args:
32         response: AI生成的原始响应
33         
34     Returns:
35         处理后的响应
36     """
37     # 例如：添加时间戳或标记
38     from datetime import datetime
39     timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
40     return f"处理时间: {timestamp}\n\n{response}"
41 
42 
43 # 示例使用
44 if __name__ == "__main__":
45     # 1. 读取并预处理需求
46     with open("requirements/feature_request.txt", "r") as f:
47         raw_requirement = f.read()
48     
49     enhanced_requirement = preprocess_requirement(raw_requirement)
50     
51     # 2. 运行工作流
52     response = run_workflow(
53         issue_id=301,
54         requirement=enhanced_requirement,
55         project_dir=os.getenv("PROJECT_DIR", "."),
56         core_model=os.getenv("CORE_MODEL", "gpt-4o"),
57         core_temperature=float(os.getenv("CORE_TEMP", "0.7"))
58     )
59     
60     # 3. 后处理响应
61     final_response = postprocess_response(response)
62     
63     print(final_response)
64
```




# 历史执行信息

【round_1】
requirement: 
为项目中的版本管理创建一个example
agent_response: 
I'll create an example file that demonstrates how to use the VersionManager class in the project. This example will show how to initialize the version manager, roll back to a previous version, and manage versioning during code generation.

Let me begin by analyzing the requirements and designing the example:

1. The example should demonstrate the key features of VersionManager
2. It should show integration with GitManager and LogManager
3. It should include rollback functionality
4. It should show how to handle version history

Here's the implementation:

```diff
--- /dev/null
+++ examples/example_version_manager.py
@@ -0,0 +1,132 @@
+"""
+本示例展示如何使用VersionManager进行代码版本管理和回滚操作
+
+版本管理是代码生成中的重要环节，能够支持：
+1. 历史记录的检索和格式化展示
+2. 对用户需求进行分析，判断是否需要回滚
+3. 执行代码版本回滚
+4. 基于不同版本进行代码生成
+"""
+
+import logging
+import os
+
+from dotenv import load_dotenv
+
+from core.ai import AIConfig
+from core.code_engineer import CodeEngineerConfig, CodeEngineer
+from core.diff import Diff
+from core.file_memory import FileMemory, FileMemoryConfig
+from core.git_manager import GitManager, GitConfig
+from core.log_config import setup_logging
+from core.log_manager import LogManager, LogConfig
+from core.prompt_generator import PromptGenerator, PromptData
+from core.version_manager import VersionManager
+
+
+def main():
+    """主函数：演示VersionManager的使用流程"""
+    setup_logging(log_level=logging.INFO)
+    # 加载环境变量
+    load_dotenv()
+    
+    # 创建工作目录
+    project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
+
+    # 设置issue_id (在实际应用中，这通常是从命令行参数或环境变量获取)
+    issue_id = 10
+    
+    # 初始化日志管理器
+    print("1. 初始化日志管理器")
+    log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)
+    log_manager = LogManager(config=log_config)
+    current_round = log_manager.get_current_round()
+    print(f"   当前轮次: {current_round}")
+    
+    # 初始化Git管理器
+    print("\n2. 初始化Git管理器")
+    git_config = GitConfig(
+        repo_path=project_dir,
+        # 可以在这里设置远程仓库URL和认证令牌
+        # remote_url="https://github.com/yourusername/yourrepo.git",
+        # auth_token=os.getenv("GITHUB_TOKEN")
+    )
+    git_manager = GitManager(config=git_config)
+    
+    # 初始化AI助手
+    print("\n3. 初始化AI配置")
+    ai_config = AIConfig(
+        model_name="gpt-4o",  # 根据需要修改模型名称
+        temperature=0.7
+    )
+    
+    # 初始化文件记忆管理器（如果需要）
+    file_memory = None
+    if current_round > 1:
+        print("\n4. 初始化文件记忆管理器")
+        file_memory = FileMemory(config=FileMemoryConfig(
+            git_manager=git_manager, 
+            ai_config=ai_config, 
+            project_dir=project_dir,
+            log_manager=log_manager
+        ))
+    
+    # 初始化版本管理器
+    print("\n5. 初始化版本管理器")
+    version_manager = VersionManager(
+        issue_id=issue_id, 
+        ai_config=ai_config,
+        log_manager=log_manager, 
+        git_manager=git_manager,
+        file_memory=file_memory
+    )
+    
+    # 示例需求
+    current_requirement = '''
+    添加一个新功能：为版本管理器添加导出历史记录为JSON的功能。
+    '''
+    print(f"\n6. 当前需求: {current_requirement}")
+    
+    # 调用版本管理器处理需求
+    print("\n7. 处理需求并获取历史记录")
+    processed_requirement, history = version_manager.ensure_version_and_generate_context(current_requirement)
+    
+    # 输出处理后的需求和历史记录
+    print(f"\n处理后的需求: {processed_requirement}")
+    print(f"\n历史记录概览: {history[:200]}..." if len(history) > 200 else f"\n历史记录: {history}")
+    
+    # 展示如何手动回滚到特定版本
+    if current_round > 1:
+        print("\n8. 演示版本回滚功能")
+        print("   注意: 此处只是演示，实际不执行回滚操作")
+        print(f"   要回滚到轮次 1，您可以使用以下代码:")
+        print("   success = version_manager._rollback_to_version(1)")
+        
+        # 获取格式化的历史记录
+        print("\n9. 获取格式化的历史记录")
+        formatted_history = version_manager.get_formatted_history()
+        print(f"   历史记录长度: {len(formatted_history)} 字符")
+        print(f"   历史记录预览: {formatted_history[:150]}..." if len(formatted_history) > 150 else formatted_history)
+        
+    # 使用版本管理器分析是否需要回滚
+    print("\n10. 分析是否需要回滚")
+    test_requirement = '''
+    之前实现的版本管理功能有严重bug，请回滚到上一个轮次，重新实现版本管理功能。
+    '''
+    print(f"    测试需求: {test_requirement}")
+    
+    if current_round > 1:
+        print("    调用version_manager._analyze_rollback_need分析是否需要回滚")
+        print("    注意: 此处只是演示，不执行实际的分析操作")
+        # rollback_needed, target_round, integrated_req, reasoning = version_manager._analyze_rollback_need(test_requirement)
+        # print(f"    分析结果: 需要回滚={rollback_needed}, 目标轮次={target_round}")
+        # print(f"    回滚原因: {reasoning[:100]}..." if reasoning and len(reasoning) > 100 else reasoning)
+    else:
+        print("    当前轮次为1，无法进行回滚分析")
+
+    print("\n示例完成！")
+
+
+if __name__ == "__main__":
+    try:
+        main()
+    except Exception as e:
+        logging.error(f"运行示例时发生错误: {str(e)}")
+        raise
```

Let's also create a complementary example showing a more advanced scenario with version rollback:

```diff
--- /dev/null
+++ examples/advanced/version_rollback_example.py
@@ -0,0 +1,95 @@
+"""
+高级示例：版本回滚操作
+
+此示例展示如何在生产环境中使用VersionManager进行版本回滚操作，
+包括自动分析和手动回滚两种方式。
+"""
+
+import logging
+import os
+from typing import Optional, Tuple
+
+from dotenv import load_dotenv
+
+from core.ai import AIConfig
+from core.git_manager import GitManager, GitConfig
+from core.log_config import setup_logging
+from core.log_manager import LogManager, LogConfig
+from core.version_manager import VersionManager
+
+
+def analyze_rollback_need(version_manager: VersionManager, requirement: str) -> Tuple[bool, Optional[int], Optional[str], Optional[str]]:
+    """
+    使用AI分析是否需要回滚到特定版本
+    
+    Args:
+        version_manager: 版本管理器实例
+        requirement: 用户需求
+        
+    Returns:
+        Tuple[bool, Optional[int], Optional[str], Optional[str]]: 
+        (是否需要回滚, 目标轮次, 整合后的需求, 分析原因)
+    """
+    return version_manager._analyze_rollback_need(requirement)
+
+
+def execute_rollback(version_manager: VersionManager, target_round: int) -> bool:
+    """
+    执行版本回滚操作
+    
+    Args:
+        version_manager: 版本管理器实例
+        target_round: 目标轮次
+        
+    Returns:
+        bool: 回滚是否成功
+    """
+    return version_manager._rollback_to_version(target_round)
+
+
+# 主程序
+def main():
+    setup_logging(log_level=logging.INFO)
+    load_dotenv()
+    
+    # 设置基本配置
+    project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../."))
+    issue_id = 10  # 使用一个示例issue_id
+    
+    # 初始化必要组件
+    log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)
+    log_manager = LogManager(config=log_config)
+    
+    git_config = GitConfig(repo_path=project_dir)
+    git_manager = GitManager(config=git_config)
+    
+    ai_config = AIConfig(model_name="gpt-4o", temperature=0.7)
+    
+    # 初始化版本管理器
+    version_manager = VersionManager(
+        issue_id=issue_id, 
+        ai_config=ai_config,
+        log_manager=log_manager, 
+        git_manager=git_manager
+    )
+    
+    # 示例用户需求（包含回滚请求）
+    user_requirement = """
+    上一轮的代码实现有严重问题，请回滚到轮次1并重新实现特性X。
+    我们需要确保新实现解决了之前遇到的性能瓶颈。
+    """
+    
+    # 分析是否需要回滚
+    print(f"分析需求是否需要回滚: {user_requirement[:50]}...")
+    rollback_needed, target_round, integrated_req, reasoning = analyze_rollback_need(version_manager, user_requirement)
+    
+    print(f"分析结果: 需要回滚={rollback_needed}, 目标轮次={target_round}")
+    print(f"分析原因: {reasoning[:100]}..." if reasoning and len(reasoning) > 100 else reasoning)
+    
+    # 如果需要回滚，执行回滚操作
+    if rollback_needed and target_round is not None:
+        print(f"执行回滚到轮次 {target_round}")
+        success = execute_rollback(version_manager, target_round)
+        print(f"回滚{'成功' if success else '失败'}")
+
+
+if __name__ == "__main__":
+    main()
```

Now, let's update the requirements.txt file to ensure all dependencies are included:

```diff
--- requirements.txt
+++ requirements.txt
@@ -1,5 +1,6 @@
 langchain==0.1.0
 langchain-openai==0.0.5
+langchain-core>=0.1.0
 python-dotenv==1.0.0
 gitpython==3.1.40
 pydantic==2.5.2
```

The examples I've created demonstrate:

1. **Basic Version Manager Usage** (`example_version_manager.py`):
   - Initializing the version manager with necessary dependencies
   - Processing requirements through version context management
   - Retrieving and formatting history
   - Demonstrating how version rollback would work

2. **Advanced Version Rollback** (`advanced/version_rollback_example.py`):
   - Using AI to analyze if rollback is needed based on user requirements
   - Executing the rollback operation when necessary
   - Integration with Git and Log management systems

These examples provide a comprehensive demonstration of the VersionManager functionality in the project, showcasing both basic usage and advanced rollback capabilities.

This concludes a fully working implementation.



# 用户需求

再给decision.py写一个example