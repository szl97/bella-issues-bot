[
  {
    "file_name": "core/version_manager.py",
    "content": "diff\n--- core/version_manager.py\n+++ core/version_manager.py\n@@ -56,12 +56,22 @@\n         self.current_issue_id = issue_id\n         self.current_round_num = log_manager.get_current_round()\n \n-    def ensure_version_and_generate_context(self, original_requirement: str) -> tuple[str, str]:\n+    def ensure_version_and_generate_context(self, original_requirement: str) -> tuple[str, str]:\n+        \"\"\"\n+        确保版本并生成上下文\n+        \n+        Args:\n+            original_requirement: 用户原始需求\n+            \n+        Returns:\n+            tuple: (处理后的需求, 历史上下文)\n+        \"\"\"\n         requirement = None\n-        if self.current_round_num > 1 :\n+        background_info = None\n+        if self.current_round_num > 1:\n             rollback, rollback_num, requirement, reasoning = self._analyze_rollback_need(original_requirement)\n-        requirement = original_requirement if requirement is None else requirement\n+        \n+        requirement = self._integrate_requirement_with_background(original_requirement, requirement)\n         history = self.get_formatted_history()\n         return requirement, history\n \n@@ -118,6 +128,73 @@\n             formatted_history.append(\"\")  # 添加空行分隔\n         return \"\\n\".join(formatted_history)\n \n+    def _extract_user_requirements_from_history(self) -> List[str]:\n+        \"\"\"\n+        从历史记录中提取所有轮次的用户需求\n+        \n+        Returns:\n+            List[str]: 用户需求列表，按轮次排序\n+        \"\"\"\n+        history = self._extract_history()\n+        requirements = []\n+        \n+        for version in history:\n+            if version.requirement:\n+                requirements.append(version.requirement)\n+        \n+        return requirements\n+    \n+    def _integrate_requirement_with_background(self, original_requirement: str, analyzed_requirement: Optional[str]) -> str:\n+        \"\"\"\n+        将用户需求与背景信息整合\n+        \n+        Args:\n+            original_requirement: 用户原始需求\n+            analyzed_requirement: 分析后的需求（可能包含背景信息）\n+            \n+        Returns:\n+            str: 整合后的需求\n+        \"\"\"\n+        if analyzed_requirement is None:\n+            return original_requirement\n+        \n+        # 如果分析后的需求就是原始需求，说明没有背景信息需要添加\n+        if analyzed_requirement == original_requirement:\n+            return original_requirement\n+        \n+        # 如果分析后的需求包含了背景信息，直接返回\n+        return analyzed_requirement\n+    \n+    def _format_background_requirements(self, requirements: List[str]) -> str:\n+        \"\"\"\n+        格式化背景需求信息\n+        \n+        Args:\n+            requirements: 需求列表\n+            \n+        Returns:\n+            str: 格式化后的背景信息\n+        \"\"\"\n+        if not requirements:\n+            return \"\"\n+        \n+        background_parts = []\n+        background_parts.append(\"## 背景信息（之前被回滚的需求）\")\n+        \n+        for i, req in enumerate(requirements, 1):\n+            background_parts.append(f\"### 需求 {i}:\")\n+            background_parts.append(req.strip())\n+            background_parts.append(\"\")  # 添加空行\n+        \n+        return \"\\n\".join(background_parts)\n+    \n+    def _should_add_background_for_full_rollback(self, target_round: int, integrated_requirement: Optional[str]) -> bool:\n+        \"\"\"\n+        判断是否需要为全量回滚添加背景信息\n+        \"\"\"\n+        return target_round == 0 and integrated_requirement is None\n+\n     def _analyze_rollback_need(self,\n                               current_requirement: str) -> Tuple[bool, Optional[int], Optional[str], Optional[str]]:\n         \"\"\"\n@@ -158,10 +235,11 @@\n ##工具参数分析\n 你需要调用 version_manager 工具来处理问题，请请根据上述信息分析以下问题，\n 1. 是否需要回退到某个特定版本? 如果需要，则调用工具时的参数 need_rollback 为 True\n-2. 如果需要回退，应该回退到哪个round?  调用工具时的参数，大于等于0，如果全部回滚则设置为0\n-3. 如果需要回退，当前需求的信息是否完整？需要把回退到的round之后的round需求与当前需求结合，作为补充信息吗? 如果需要结合，则将重写后的本轮需求，作为integrated_requirement参数；如果不需要则不需要此参数。\n+2. 如果需要回退，应该回退到哪个round? 调用工具时的参数，大于等于0，如果全部回滚则设置为0\n+3. 如果需要回退，当前需求的信息是否完整？需要把回退到的round之后的round需求与当前需求结合，作为补充信息吗? 如果需要结合，则将重写后的本轮需求，作为integrated_requirement参数；如果不需要则不需要此参数。\n 4. 做出这个决策的原因是什么？调用工具时，作为reasoning参数\n \n+注意：如果回滚到第一轮（target_round为0）且不需要整合需求（integrated_requirement为None），系统会自动将被回滚的需求作为背景信息添加到当前需求中。\n ##工具执行\n 根据得到的参数，调用version_manager。无论是否需要rollback必须调用工具执行任务，完成当前版本的创建。\n \n@@ -298,7 +376,7 @@\n         \"\"\"\n         def version_manager_tool(need_rollback: bool,\n                                           target_round: Optional[int] = None,\n-                                          integrated_requirement: Optional[str] = None,\n+                                          integrated_requirement: Optional[str] = None,\n                                           reasoning: Optional[str] = None) -> Tuple[str, Optional[int], Optional[str], Optional[str]]:\n             \"\"\"\n             决定是否回退版本并执行回退\n@@ -315,9 +393,25 @@\n             \n             if need_rollback and target_round is not None:\n                 success = self._rollback_to_version(target_round)\n-                if(success) :\n-                    return (True, target_round, integrated_requirement, reasoning)\n+                if success:\n+                    # 如果是全量回滚且没有整合需求，需要添加背景信息\n+                    final_integrated_requirement = integrated_requirement\n+                    if self._should_add_background_for_full_rollback(target_round, integrated_requirement):\n+                        # 获取被回滚的所有用户需求作为背景\n+                        rollback_requirements = self._extract_user_requirements_from_history()\n+                        if rollback_requirements:\n+                            background_info = self._format_background_requirements(rollback_requirements)\n+                            # 将背景信息与当前需求整合\n+                            final_integrated_requirement = f\"{background_info}\\n\\n## 当前需求\\n{current_requirement if 'current_requirement' in locals() else ''}\"\n+                    \n+                    return (True, target_round, final_integrated_requirement, reasoning)\n                 else:\n-                    logger.warning(f\"版本回退失败:issues:{self.current_issue_id},target:{target_round},integrated_requirement:{integrated_requirement}\")\n+                    logger.warning(f\"版本回退失败:issues:{self.current_issue_id},target:{target_round},integrated_requirement:{final_integrated_requirement}\")\n+            return (False, 0, None, reasoning)\n+        \n+        # 保存当前需求的引用，以便在工具函数中使用\n+        def version_manager_tool_wrapper(need_rollback: bool,\n+                                       target_round: Optional[int] = None,\n+                                       integrated_requirement: Optional[str] = None,\n+                                       reasoning: Optional[str] = None):\n+            # 获取调用时的当前需求（通过闭包访问）\n+            current_req = getattr(self, '_current_analyzing_requirement', '')\n+            \n+            if need_rollback and target_round is not None:\n+                success = self._rollback_to_version(target_round)\n+                if success:\n+                    # 如果是全量回滚且没有整合需求，需要添加背景信息\n+                    final_integrated_requirement = integrated_requirement\n+                    if self._should_add_background_for_full_rollback(target_round, integrated_requirement):\n+                        # 获取被回滚的所有用户需求作为背景\n+                        rollback_requirements = self._extract_user_requirements_from_history()\n+                        if rollback_requirements:\n+                            background_info = self._format_background_requirements(rollback_requirements)\n+                            # 将背景信息与当前需求整合\n+                            final_integrated_requirement = f\"{background_info}\\n\\n## 当前需求\\n{current_req}\"\n+                    \n+                    return (True, target_round, final_integrated_requirement, reasoning)\n+                else:\n+                    logger.warning(f\"版本回退失败:issues:{self.current_issue_id},target:{target_round},integrated_requirement:{integrated_requirement}\")\n             return (False, 0, None, reasoning)\n         \n         return StructuredTool.from_function(\n             name=\"version_rollback_manager\",\n             description=\"用于决定当前项目版本的工具，如果 need_rollback 为True，则根据target_round和integrated_requirement进行版本回退；如果need_rollback为False则保持当前版本\",\n-            func=version_manager_tool,\n+            func=version_manager_tool_wrapper,\n             return_direct=True,\n             args_schema=self._VersionManagerToolSchema\n         )\n@@ -129,6 +129,9 @@\n         分析是否需要版本回退\n         \n         Args:\n             current_requirement: 当前用户需求\n             \n         Returns:\n             Tuple[bool, int, str, str]: (是否需要回退, 回退到的轮次, 整合后的需求，决策的原因)\n         \"\"\"\n+        # 保存当前需求用于工具函数访问\n+        self._current_analyzing_requirement = current_requirement\n+        \n         # 获取历史记录\n         history = self.get_formatted_history()\n         \n         # 构建提示词\n\n",
    "file_content": "\"\"\"\n版本管理模块，处理代码生成的版本控制、历史追踪和回退功能。\n\n该模块提供了以下功能:\n1. 提取历史轮次的日志信息\n2. 格式化历史执行记录用于AI参考\n3. 分析用户需求，决定是否需要版本回退\n4. 执行Git版本回退操作\n5. 为AI助手提供版本回退工具\n\"\"\"\n\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\n\nfrom langchain_core.tools import Tool, StructuredTool\nfrom pydantic import BaseModel, Field\n\nfrom core.ai import AIConfig, AIAssistant\nfrom core.git_manager import GitManager\nfrom core.log_config import get_logger\nfrom core.log_manager import LogManager\nfrom core.prompt_generator import PromptGenerator\n\nlogger = get_logger(__name__)\n\n@dataclass\nclass VersionInfo:\n    \"\"\"存储特定版本的信息\"\"\"\n    issue_id: int\n    round_num: int\n    requirement: str\n    agent_response: str\n    modified_files: List[str] = None\n\n\nclass VersionManager:\n    \"\"\"管理代码生成的版本信息，支持版本回退和需求整合\"\"\"\n\n    def __init__(self, issue_id: int, ai_config: AIConfig, log_manager: LogManager, git_manager: GitManager, file_memory=None):\n        \"\"\"\n        初始化版本管理器\n        \n        Args:\n            issue_id: GitHub issue编号\n            ai_config: AI配置\n            log_manager: 日志管理器实例 \n            git_manager: Git管理器实例\n            file_memory: 文件内存管理器实例(可选)\n        \"\"\"\n        self.ai_assistant = AIAssistant(config=ai_config, tools=[self._create_version_manager_tool()])\n        self.file_memory = file_memory\n        self.log_manager = log_manager\n        self.git_manager = git_manager\n        self.current_issue_id = issue_id\n        self.current_round_num = log_manager.get_current_round()\n\n    def ensure_version_and_generate_context(self, original_requirement: str) -> tuple[str, str]:\n        requirement = None\n        if self.current_round_num > 1 :\n            rollback, rollback_num, requirement, reasoning = self._analyze_rollback_need(original_requirement)\n        requirement = original_requirement if requirement is None else requirement\n        history = self.get_formatted_history()\n        return requirement, history\n\n    \n    def _extract_history(self) -> List[VersionInfo]:\n        \"\"\"\n        提取当前issue的历史版本信息\n            \n        Returns:\n            List[VersionInfo]: 历史版本信息列表\n        \"\"\"\n        # 获取所有轮次的日志条目\n        log_entries = self.log_manager.get_issue_log_entries()\n        \n        # 提取每轮的需求和响应\n        version_info_list = []\n        for entry in log_entries:\n            try:\n                # 从用户提示中提取需求\n                extracted_info = PromptGenerator.extractInfo(entry.prompt)\n                requirement = extracted_info.requirement\n                \n                # 创建版本信息\n                version_info = VersionInfo(\n                    issue_id=self.current_issue_id,\n                    round_num=entry.round_num,\n                    requirement=requirement,\n                    agent_response=entry.response,\n                    modified_files=entry.modified_files\n                )\n                version_info_list.append(version_info)\n                \n            except Exception as e:\n                logger.error(f\"提取轮次 {entry.round_num} 的信息时出错: {str(e)}\")\n        \n        return version_info_list\n\n    def get_formatted_history(self) -> str:\n        \"\"\"\n        获取格式化的历史执行记录\n        \n        Args:\n            \n        Returns:\n            str: 格式化的历史执行记录\n        \"\"\"\n        history = self._extract_history()\n        formatted_history = []\n        \n        for version in history:\n            formatted_history.append(f\"【round_{version.round_num}】\")\n            formatted_history.append(f\"requirement: \\n{version.requirement}\")\n            \n            # 简化AI响应，避免历史记录过长\n            formatted_history.append(f\"agent_response: \\n{version.agent_response}\")\n            formatted_history.append(\"\")  # 添加空行分隔\n        return \"\\n\".join(formatted_history)\n\n    def _analyze_rollback_need(self,\n                              current_requirement: str) -> Tuple[bool, Optional[int], Optional[str], Optional[str]]:\n        \"\"\"\n        分析是否需要版本回退\n        \n        Args:\n            current_requirement: 当前用户需求\n            \n        Returns:\n            Tuple[bool, int, str, str]: (是否需要回退, 回退到的轮次, 整合后的需求，决策的原因)\n        \"\"\"\n        # 获取历史记录\n        history = self.get_formatted_history()\n        \n        # 构建提示词\n        prompt = f\"\"\"\n# 角色\n你是一位资深程序员，现在在处理用户的issues，请分析本次用户提出的需求和历史执行记录，判断之前提交的代码是否需要版本回退。并调用工具完成版本的创建。\n\n#注意\n需要重置的轮次如果就是上一个轮次，那么就是不需要回退。\n\n##需求回退的情况举例\n- 最后一个round是5，假如你认为round4和round5的改动极其不符合，会影响用户需求的实现，那么就需要回滚4和5，此次的需求基于round3修改，target_round为1\n- 最后一个round是4，假如你认为之前的所有修改都极其不符合用户需求或错误，重新改更有利，那么用户此次的需求应该基于原始代码修改，那么就需要回滚所有改动，target_round为0\n\n##不需要回滚的情况举例\n- 最后一个round是5，假如你认为用户的此次需求，在round5的代码上改动即可，那么就可以不回滚，直接修改\n\n# 历史执行记录\n{history}\n\n# 当前用户需求\n{current_requirement}\n\n\n#执行步骤\n##工具参数分析\n你需要调用 version_manager 工具来处理问题，请请根据上述信息分析以下问题，\n1. 是否需要回退到某个特定版本? 如果需要，则调用工具时的参数 need_rollback 为 True\n2. 如果需要回退，应该回退到哪个round?  调用工具时的参数，大于等于0，如果全部回滚则设置为0\n3. 如果需要回退，当前需求的信息是否完整？需要把回退到的round之后的round需求与当前需求结合，作为补充信息吗? 如果需要结合，则将重写后的本轮需求，作为integrated_requirement参数；如果不需要则不需要此参数。\n4. 做出这个决策的原因是什么？调用工具时，作为reasoning参数\n\n##工具执行\n根据得到的参数，调用version_manager。无论是否需要rollback必须调用工具执行任务，完成当前版本的创建。\n\n\"\"\"\n\n        # 发送给AI进行分析\n        response = self.ai_assistant.generate_response(prompt, use_tools=True)\n\n        return response if response else (False, 0, current_requirement)\n\n    def _rollback_to_version(self, target_round: int) -> bool:\n        \"\"\"\n        执行基于文件的版本回退\n        \n        Args:\n            target_round: 目标轮次\n            \n        Returns:\n            bool: 回退是否成功\n        \"\"\"\n        try:\n            # 获取目标轮次的日志条目\n            log_entries = self.log_manager.get_issue_log_entries(include_diff=True)\n            \n            if not log_entries:\n                logger.error(\"找不到任何日志条目\")\n                return False\n            \n            # 获取当前轮次到目标轮次之间的所有轮次记录，按轮次降序排列（从最新到最旧）\n            entries_to_rollback = sorted(\n                [entry for entry in log_entries if entry.round_num > target_round],\n                key=lambda entry: entry.round_num,\n                reverse=True\n            )\n            \n            if not entries_to_rollback:\n                logger.info(f\"当前已经是轮次 {target_round} 或更早，无需回滚\")\n                return True\n            \n            # 依次回滚每一轮的修改\n            import os\n            project_dir = self.log_manager.config.project_dir\n            \n            for entry in entries_to_rollback:\n                logger.info(f\"正在回滚轮次 {entry.round_num} 的修改...\")\n                \n                if not entry.modified_files:\n                    logger.info(f\"轮次 {entry.round_num} 没有文件修改，跳过\")\n                    continue\n                \n                # 对每个修改的文件进行回滚\n                for diff_info in entry.modified_files:\n                    file_path = os.path.join(project_dir, diff_info.file_name)\n                    \n                    if diff_info.is_create:\n                        # 如果是创建操作，则删除该文件\n                        if os.path.exists(file_path):\n                            os.remove(file_path)\n                            logger.info(f\"删除文件 {diff_info.file_name}，回滚轮次 {entry.round_num} 的创建操作\")\n                    \n                    elif diff_info.is_modify:\n                        # 如果是修改操作，则恢复到修改前的内容\n                        if diff_info.file_content is not None:\n                            os.makedirs(os.path.dirname(file_path), exist_ok=True)\n                            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                                f.write(diff_info.file_content)\n                            logger.info(f\"恢复文件 {diff_info.file_name} 到轮次 {entry.round_num} 修改前的状态\")\n                        else:\n                            logger.warning(f\"文件 {diff_info.file_name} 没有保存修改前的内容，无法回滚\")\n                    \n                    elif diff_info.is_delete:\n                        # 如果是删除操作，则恢复文件\n                        if diff_info.file_content is not None:\n                            os.makedirs(os.path.dirname(file_path), exist_ok=True)\n                            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                                f.write(diff_info.file_content)\n                            logger.info(f\"恢复文件 {diff_info.file_name}，回滚轮次 {entry.round_num} 的删除操作\")\n                        else:\n                            logger.warning(f\"文件 {diff_info.file_name} 没有保存删除前的内容，无法回滚\")\n\n            self.log_manager.rollback_logs(target_round)\n            logger.info(f\"成功回滚到轮次 {target_round}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"文件版本回退失败: {str(e)}\")\n            return False\n\n    def _rollback_to_version_git(self, target_round: int) -> bool:\n        \"\"\"\n        执行版本回退\n        \n        Args:\n            target_round: 目标轮次\n            \n        Returns:\n            bool: 回退是否成功\n        \"\"\"\n        try:\n            # 构建目标分支名\n            target_branch = f\"bella-bot-issues-{self.current_issue_id}-{target_round}\"\n            return self.git_manager.reset_to(target_branch)\n            \n        except Exception as e:\n            logger.error(f\"Git版本回退失败: {str(e)}\")\n            return False\n\n    class _VersionManagerToolSchema(BaseModel):\n        need_rollback: bool = Field(\n            ...,\n            examples=[True, False],\n            description=\"是否需要回退版本\"\n        )\n        target_round: Optional[int] = Field(\n            None,\n            examples=[0,1,2,3,4],\n            description=\"要回滚到的目标轮次，只有need_rollback为True时需要且必须.0代表需要全部回滚。\"\n        )\n        integrated_requirement: Optional[str] = Field(\n            None,\n            description=\"整合后的需求，只有need_rollback为True且需要重写需求时需要\"\n        )\n        reasoning: Optional[str] = Field(\n            None,\n            description=\"做这个出决策的原因\"\n        )\n\n    def _create_version_manager_tool(self) -> StructuredTool:\n        \"\"\"\n        版本管理工具，供AI助手使用\n            \n        Returns:\n            Tool: 版本管理工具\n        \"\"\"\n        def version_manager_tool(need_rollback: bool,\n                                          target_round: Optional[int] = None,\n                                          integrated_requirement: Optional[str] = None,\n                                          reasoning: Optional[str] = None) -> Tuple[str, Optional[int], Optional[str], Optional[str]]:\n            \"\"\"\n            决定是否回退版本并执行回退\n            \n            Args:\n                need_rollback:是否需要回退,\n                target_round：回退到的轮次,\n                integrated_requirement： 整合后的需求\n                reasoning: 做出决策的原因\n                \n            Returns:\n                str: 执行结果\n            \"\"\"\n            \n            if need_rollback and target_round is not None:\n                success = self._rollback_to_version(target_round)\n                if(success) :\n                    return (True, target_round, integrated_requirement, reasoning)\n                else:\n                    logger.warning(f\"版本回退失败:issues:{self.current_issue_id},target:{target_round},integrated_requirement:{integrated_requirement}\")\n            return (False, 0, None, reasoning)\n        \n        return StructuredTool.from_function(\n            name=\"version_rollback_manager\",\n            description=\"用于决定当前项目版本的工具，如果 need_rollback 为True，则根据target_round和integrated_requirement进行版本回退；如果need_rollback为False则保持当前版本\",\n            func=version_manager_tool,\n            return_direct=True,\n            args_schema=self._VersionManagerToolSchema\n        )\n",
    "is_create": false,
    "is_modify": true,
    "is_delete": false
  }
]