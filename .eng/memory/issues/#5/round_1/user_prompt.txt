# 项目文件描述


- core/log_manager.py: 管理代码生成日志的存储和检索。包含LogManager类，用于存档系统提示词、用户提示词、AI响应等内容，支持按issue和轮次组织日志。提供archive_logs和get_issue_log_entries等方法，记录代码生成过程。

- examples/example_code_generate.py: 代码生成流程示例，展示如何使用CodeEngineer处理代码修改需求。演示了从需求分析到代码生成和提交的完整流程，包含main函数作为入口点。

- examples/example_workflow.py: WorkflowEngine使用示例，演示如何配置和初始化工作流引擎处理用户需求。创建WorkflowEngineConfig配置，设置项目目录、模型参数等，调用process_requirement方法处理需求。作为框架使用的入门示例。

- core/workflow_engine.py: 工作流引擎核心组件，协调版本管理、日志管理和AI交互。包含WorkflowEngine类和WorkflowEngineConfig配置类，负责处理用户需求，根据需求类型执行代码修改或聊天回复流程，是系统的核心协调器。

- README.md: bella-issues-bot项目的中文README文件，详细介绍了项目简介、主要功能、记忆系统（日志管理、版本管理、文件记忆）、安装方法、配置选项和详细使用示例，还包含项目结构说明，全面展示了这个AI代码开发助手的功能和用法。

- README.en.md: bella-issues-bot项目的英文README文件，介绍了项目概览、核心功能、记忆系统架构（LogManager、VersionManager和FileMemory）、安装方法和配置选项。重点说明了项目的两种工作模式和三大记忆组件的工作原理。


# 文件内容



```
File: core/log_manager.py
1 import datetime
2 import os
3 import json
4 import shutil
5 from dataclasses import dataclass, field
6 from typing import List, Optional
7 from pydantic import BaseModel
8 
9 from core.diff import DiffInfo
10 from core.log_config import get_logger
11 
12 logger = get_logger(__name__)
13 
14 @dataclass
15 class LogConfig:
16     """日志管理配置"""
17 
18     project_dir: str
19     issue_id: int
20     mode: str = "client" # ["client", "bot"]
21 
22 
23 class LogEntry(BaseModel):
24     """存储单次代码生成日志的数据类"""
25     issue_id: int
26     round_num: int
27     sys_prompt: str
28     prompt: str
29     response: str
30     timestamp: str = datetime.datetime.now().isoformat()
31     log_path: str = ""
32     modified_files: List[DiffInfo] = []
33 
34 
35 class LogManager:
36     """管理代码生成日志的存档和检索"""
37     base_dir: str = ".eng"
38     logs_base_dir: str = "memory"
39     rollback_dir: str = "rollback"
40 
41     def __init__(self, config: LogConfig):
42         """
43         初始化日志管理器
44 
45         Args:
46             config: LogConfig实例，包含必要的配置信息
47         """
48         self.config = config
49         self.issue_id = self.config.issue_id
50 
51         
52         # 根据模式选择存储目录
53         if self.config.mode == "bot":
54             logs_dir = "issues"
55         else:
56             logs_dir = "queries"
57             
58         # 构建完整的日志存储路径
59         self.logs_path = os.path.join(
60             self.config.project_dir, 
61             self.base_dir,
62             self.logs_base_dir,
63             logs_dir)
64         self.issues_path = os.path.join(
65             self.logs_path, "#" + str(self.issue_id)
66         )
67 
68         self.rollback_path = os.path.join(
69             self.logs_path, "#" + str(self.issue_id), self.rollback_dir
70         )
71 
72         # 初始化当前轮次
73         self.current_round = self._get_next_round()
74 
75         # 确保必要的目录存在
76         os.makedirs(self.issues_path, exist_ok=True)
77         os.makedirs(self.rollback_path, exist_ok=True)
78 
79         # 定义日志文件名常量
80         self.SYS_PROMPT_FILE = "system_prompt.txt"
81         self.USER_PROMPT_FILE = "user_prompt.txt"
82         self.AI_RESPONSE_FILE = "ai_response.txt"
83         self.TIMESTAMP_FILE = "timestamp.txt"
84         self.MODIFIED_FILES_FILE = "modified_files.txt"
85 
86     def archive_logs(self, sys_prompt: str, prompt: str, response: str, diff_infos: List[DiffInfo] = None) -> str:
87         """
88         将代码生成日志存档到指定的目录
89 
90         Args:
91             diff_infos: 文件的修改信息
92             sys_prompt: 系统提示词
93             prompt: 用户提示词
94             response: AI响应
95 
96         Returns:
97             str: 存档目录的路径
98         """
99         # 获取下一个轮次号
100 
101         round_num = self.current_round
102 
103         # 获取当前时间戳
104         timestamp = datetime.datetime.now().isoformat()
105         
106         # 创建轮次目录
107         round_dir = os.path.join(self.issues_path, f"round_{round_num}")
108         os.makedirs(round_dir, exist_ok=True)
109         
110         # 保存系统提示词
111         with open(os.path.join(round_dir, self.SYS_PROMPT_FILE), "w", encoding="utf-8") as f:
112             f.write(sys_prompt)
113         
114         # 保存用户提示词
115         with open(os.path.join(round_dir, self.USER_PROMPT_FILE), "w", encoding="utf-8") as f:
116             f.write(prompt)
117         
118         # 保存AI响应
119         with open(os.path.join(round_dir, self.AI_RESPONSE_FILE), "w", encoding="utf-8") as f:
120             f.write(response)
121             
122         # 保存时间戳
123         with open(os.path.join(round_dir, self.TIMESTAMP_FILE), "w", encoding="utf-8") as f:
124             f.write(timestamp)
125 
126         # 保存修改的文件列表
127         if diff_infos:
128             # 使用 Pydantic 的 dict 方法进行序列化
129             diff_dicts = [diff.dict() for diff in diff_infos]
130                 
131             # 序列化为 JSON 并保存
132             with open(os.path.join(round_dir, self.MODIFIED_FILES_FILE), "w", encoding="utf-8") as f:
133                 json.dump(diff_dicts, f, ensure_ascii=False, indent=2)
134             logger.info(f"保存了 {len(diff_infos)} 个修改的文件记录")
135         
136         # 记录日志
137         logger.info(f"已将日志存档至: {round_dir}")
138         
139         # 返回存档目录的路径
140         return round_dir
141 
142     def _get_next_round(self) -> int:
143         """
144         获取下一个轮次号
145 
146         Returns:
147             int: 下一个轮次号
148         """
149         issue_path = self.issues_path
150         if not os.path.exists(issue_path):
151             return 1
152 
153         existing_rounds = [
154             int(d[6:])
155             for d in os.listdir(issue_path)
156             if os.path.isdir(os.path.join(issue_path, d)) and (d[6:]).isdigit()
157         ]
158 
159         return max(existing_rounds, default=0) + 1
160 
161     def get_current_round(self) -> int:
162         return self.current_round
163         
164     def get_issue_log_entries(self, include_diff: bool = False) -> List[LogEntry]:
165         """
166         获取当前issue的所有轮次的日志条目
167 
168         Returns:
169             List[LogEntry]: 日志条目列表，按轮次排序
170         """
171         
172         log_entries = []
173 
174         issue_dir = self.issues_path
175         # 遍历所有轮次目录
176         for dir_name in os.listdir(issue_dir):
177             if not dir_name.startswith("round_"):
178                 continue
179                 
180             try:
181                 round_num = int(dir_name[6:])  # 提取轮次号
182                 round_dir = os.path.join(issue_dir, dir_name)
183                 
184                 # 读取系统提示词
185                 sys_prompt_path = os.path.join(round_dir, self.SYS_PROMPT_FILE)
186                 with open(sys_prompt_path, "r", encoding="utf-8") as f:
187                     sys_prompt = f.read()
188                 
189                 # 读取用户提示词
190                 user_prompt_path = os.path.join(round_dir, self.USER_PROMPT_FILE)
191                 with open(user_prompt_path, "r", encoding="utf-8") as f:
192                     prompt = f.read()
193                 
194                 # 读取AI响应
195                 ai_response_path = os.path.join(round_dir, self.AI_RESPONSE_FILE)
196                 with open(ai_response_path, "r", encoding="utf-8") as f:
197                     response = f.read()
198                     
199                 # 读取修改的文件列表(如果存在)
200                 modified_files = []
201                 if include_diff:
202                     modified_files_path = os.path.join(round_dir, self.MODIFIED_FILES_FILE)
203                     if os.path.exists(modified_files_path):
204                         try:
205                             with open(modified_files_path, "r", encoding="utf-8") as f:
206                                 diff_dicts = json.load(f)
207                                 
208                                 # 将字典转换回 DiffInfo 对象
209                                 modified_files = [DiffInfo(**diff_dict) for diff_dict in diff_dicts]
210                         except Exception as e:
211                             logger.error(f"读取修改文件列表失败: {str(e)}")
212                     
213                 # 读取时间戳
214                 timestamp_path = os.path.join(round_dir, self.TIMESTAMP_FILE)
215                 timestamp = datetime.datetime.now().isoformat()  # 默认当前时间
216                 if os.path.exists(timestamp_path):
217                     try:
218                         with open(timestamp_path, "r", encoding="utf-8") as f:
219                             timestamp = f.read().strip()
220                     except Exception as e:
221                         logger.error(f"读取时间戳失败: {str(e)}")
222                 
223                 # 创建并添加LogEntry对象
224                 entry = LogEntry(issue_id=self.issue_id, round_num=round_num,
225                                  sys_prompt=sys_prompt, prompt=prompt, 
226                                  response=response, timestamp=timestamp, log_path=round_dir,
227                                  modified_files=modified_files)
228                 log_entries.append(entry)
229             except Exception as e:
230                 logger.error(f"读取轮次 {dir_name} 的日志失败: {str(e)}")
231         
232         # 按轮次号排序
233         return sorted(log_entries, key=lambda entry: entry.round_num)
234     
235     def get_issue_round_log_entry(self, round_num: int, include_diff: bool = False) -> Optional[LogEntry]:
236         """
237         获取特定轮次的日志条目
238 
239         Args:
240             round_num: 轮次号
241             include_diff: 是否包含修改信息
242 
243         Returns:
244             Optional[LogEntry]: 指定轮次的日志条目，如果不存在则返回None
245         """
246         round_dir = os.path.join(self.issues_path, f"round_{round_num}")
247         
248         if not os.path.exists(round_dir):
249             logger.warning(f"Issue #{self.issue_id} 的轮次 {round_num} 不存在")
250             return None
251             
252         try:
253             # 直接使用现有方法获取所有轮次，然后过滤出指定轮次
254             all_entries = self.get_issue_log_entries(include_diff)
255             return next((entry for entry in all_entries if entry.round_num == round_num), None)
256         except Exception as e:
257             logger.error(f"获取 Issue #{self.issue_id} 轮次 {round_num} 的日志失败: {str(e)}")
258             return None
259             
260     def rollback_logs(self, target_round: int) -> bool:
261         """
262         将目标轮次之后的日志移至回滚目录
263         
264         Args:
265             target_round: 保留到的轮次，之后的轮次会被移到回滚目录
266             
267         Returns:
268             bool: 操作是否成功
269         """
270         try:
271             # 确保回滚目录存在
272             os.makedirs(self.rollback_path, exist_ok=True)
273             
274             # 获取所有轮次目录
275             round_dirs = [d for d in os.listdir(self.issues_path) 
276                          if os.path.isdir(os.path.join(self.issues_path, d)) 
277                          and d.startswith("round_")]
278             
279             # 筛选出需要回滚的轮次目录
280             rounds_to_rollback = []
281             for dir_name in round_dirs:
282                 try:
283                     round_num = int(dir_name[6:])  # 提取轮次号
284                     if round_num > target_round:
285                         rounds_to_rollback.append((round_num, dir_name))
286                 except ValueError:
287                     continue
288             
289             # 按轮次号排序
290             rounds_to_rollback.sort(key=lambda x: x[0])
291             
292             if not rounds_to_rollback:
293                 logger.info(f"没有轮次需要回滚")
294                 return True
295                 
296             # 移动轮次日志到回滚目录
297             for round_num, dir_name in rounds_to_rollback:
298                 source_path = os.path.join(self.issues_path, dir_name)
299                 dest_path = os.path.join(self.rollback_path, dir_name)
300                 
301                 # 如果目标路径已存在，先删除
302                 if os.path.exists(dest_path):
303                     shutil.rmtree(dest_path)
304                     
305                 # 移动目录
306                 shutil.move(source_path, dest_path)
307                 logger.info(f"已将轮次 {round_num} 的日志移至回滚目录: {dest_path}")
308             
309             # 更新当前轮次
310             self.current_round = self._get_next_round()
311             return True
312             
313         except Exception as e:
314             logger.error(f"回滚日志失败: {str(e)}")
315             return False
316     
317     def get_rollback_log_entries(self, include_diff: bool = False) -> List[LogEntry]:
318         """
319         获取已回滚的所有轮次的日志条目
320 
321         Args:
322             include_diff: 是否包含diff信息
323 
324         Returns:
325             List[LogEntry]: 回滚的日志条目列表，按轮次排序
326         """
327         try:
328             # 如果回滚目录不存在，返回空列表
329             if not os.path.exists(self.rollback_path):
330                 return []
331                 
332             # 临时保存当前issues_path
333             original_path = self.issues_path
334             
335             # 将issues_path指向rollback_path，复用get_issue_log_entries方法
336             self.issues_path = self.rollback_path
337             
338             # 获取回滚目录中的日志条目
339             rollback_entries = self.get_issue_log_entries(include_diff)
340             
341             # 恢复issues_path
342             self.issues_path = original_path
343             
344             return rollback_entries
345         except Exception as e:
346             logger.error(f"获取回滚日志条目失败: {str(e)}")
347             return []
348 
349 if __name__ == "__main__":
350     config = LogConfig("..", 1)
351     log_manager = LogManager(config)
352
```




```
File: examples/example_code_generate.py
1 import logging
2 import os
3 
4 from dotenv import load_dotenv
5 
6 from core.ai import AIConfig
7 from core.code_engineer import CodeEngineerConfig, CodeEngineer
8 from core.diff import Diff
9 from core.file_memory import FileMemory, FileMemoryConfig
10 from core.file_selector import FileSelector
11 from core.git_manager import GitManager, GitConfig
12 from core.log_config import setup_logging
13 from core.log_manager import LogManager, LogConfig
14 from core.prompt_generator import PromptGenerator, PromptData
15 from core.version_manager import VersionManager
16 
17 
18 def main():
19     setup_logging(log_level=logging.DEBUG)
20     # 加载环境变量
21     load_dotenv()
22     
23     # 创建工作目录
24     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
25 
26     issue_id = 3
27     
28     # 初始化日志管理器
29     log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)
30     log_manager = LogManager(config=log_config)
31     current_round = log_manager.get_current_round()
32 
33     
34     # 初始化Git管理器
35     git_config = GitConfig(
36         repo_path=project_dir
37     )
38     git_manager = GitManager(config=git_config)
39     
40     # 初始化AI助手
41     ai_config = AIConfig(
42         model_name="coder-model",
43         temperature=1
44     )
45     
46     # 初始化版本管理器
47     version_manager = VersionManager(issue_id=issue_id, log_manager=log_manager, git_manager=git_manager, ai_config=ai_config)
48 
49     current_requirement = '''
50     将 example_chat_process.py 和 example_code_generate.py的流程整合到 workflow_engine.py 中，目前两个代码文件都是写代码和回复用户的完整流程。
51     使用DecisionEnvironment来决策选择何种模式。
52     '''
53     requirement, history = version_manager.ensure_version_and_generate_context(current_requirement)
54 
55     if current_round > 1:
56         file_memory = FileMemory(config=FileMemoryConfig(git_manager=git_manager, ai_config=ai_config, project_dir=project_dir))
57         file_memory.update_file_details()
58 
59     selector = FileSelector(
60         project_dir,
61         issue_id,
62         ai_config=ai_config,
63     )
64 
65     files = selector.select_files_for_requirement(requirement)
66 
67     descriptions = FileMemory.get_selected_file_descriptions(project_dir, files)
68 
69     data = PromptData(requirement=requirement, project_dir=project_dir, steps = history, files=files, file_desc=descriptions)
70     user_prompt = PromptGenerator.generatePrompt(data)
71     config = CodeEngineerConfig(project_dir=project_dir, ai_config=ai_config)
72 
73     engineer = CodeEngineer(config, LogManager(LogConfig(project_dir=project_dir, issue_id=issue_id)), Diff(AIConfig(temperature=0.1,
74                                                                                                               model_name="gpt-4o")))
75     engineer.process_prompt(prompt=user_prompt)
76 
77 
78 if __name__ == "__main__":
79     main()
80
```




```
File: examples/example_workflow.py
1 """
2 这个示例展示如何使用WorkflowEngine处理用户需求，自动决策是代码生成还是对话流程
3 """
4 import logging
5 import os
6 
7 from dotenv import load_dotenv
8 
9 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
10 from core.log_config import setup_logging
11 
12 
13 def main():
14     setup_logging(log_level=logging.DEBUG)
15     # 加载环境变量
16     load_dotenv()
17     
18     # 创建工作目录
19     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
20     issue_id = 5
21     
22     # 创建工作流引擎配置
23     config = WorkflowEngineConfig(
24         project_dir=project_dir,
25         issue_id=issue_id,
26         core_model="coder-model",
27         data_model="gpt-4o",
28         core_template=1,
29         data_template=0.7,
30         default_branch="dev"
31     )
32     
33     # 初始化工作流引擎
34     workflow_engine = WorkflowEngine(config)
35 
36     requirement = """
37     分析项目的所有代码。把项目的Read.me进行完善。尤其是未完成的。
38     """
39     
40     # 处理代码修改需求
41     workflow_engine.process_requirement(requirement)
42 
43 if __name__ == "__main__":
44     main()
45
```




```
File: core/workflow_engine.py
1 import os
2 import shutil
3 import tempfile
4 import uuid
5 from dataclasses import dataclass
6 from typing import Optional
7 
8 from core.ai import AIConfig
9 from core.chat_processor import ChatProcessor, ChatProcessorConfig
10 from core.code_engineer import CodeEngineer, CodeEngineerConfig
11 from core.decision import DecisionProcess
12 from core.diff import Diff
13 from core.file_memory import FileMemory, FileMemoryConfig
14 from core.file_selector import FileSelector
15 from core.git_manager import GitManager, GitConfig
16 from core.log_config import get_logger
17 from core.log_manager import LogManager, LogConfig
18 from core.prompt_generator import PromptGenerator, PromptData
19 from core.version_manager import VersionManager
20 
21 logger = get_logger(__name__)
22 
23 @dataclass
24 class WorkflowEngineConfig:
25     project_dir: str
26     issue_id:int
27     core_model:str = "gpt-4o"
28     data_model:str = "gpt-4o"
29     core_template: float = 0.7
30     data_template: float = 0.7
31     max_retry: int = 3,
32     default_branch: str = "main"
33     mode: str = "client" # ["client", "bot"] bot模式下，每次进行工作时，会hard reset到issues的最新分支上
34     base_url: Optional[str] = None
35     api_key: Optional[str] = None
36     github_remote_url: Optional[str] =None
37     github_token: Optional[str] = None
38 
39 
40 class WorkflowEngine:
41     CODE_TIMES = 0
42     CHAT_TIMES = 0
43     """
44     工作流引擎，协调版本管理、日志管理和AI交互
45     """
46     def __init__(self, config: WorkflowEngineConfig):
47         """
48         初始化工作流引擎
49         
50         Args:
51             config: 工作流配置
52         """
53         self.CODE_TIMES = 0
54         self.CHAT_TIMES = 0
55         # 存储原始配置
56         self.original_config = config
57         
58         # 根据模式设置工作目录
59         if config.mode == "bot":
60             # 创建临时目录作为工作区
61             self.temp_dir = os.path.join(
62                 tempfile.gettempdir(),
63                 f"bella-bot-{config.issue_id}-{str(uuid.uuid4())[:8]}"
64             )
65             os.makedirs(self.temp_dir, exist_ok=True)
66             # 更新配置以使用临时目录
67             self.config = WorkflowEngineConfig(
68                 project_dir=self.temp_dir,
69                 **{k: v for k, v in vars(config).items() if k != 'project_dir'}
70             )
71             logger.info(f"Bot模式：创建临时工作目录 {self.temp_dir}")
72         else:
73             # 客户端模式直接使用指定的目录
74             self.config = config
75             self.temp_dir = None
76             logger.info("当前为client模式")
77 
78         self.project_dir = os.path.abspath(self.config.project_dir)
79         # 创建AI配置
80         self.core_ai_config = AIConfig(
81             model_name=config.core_model,
82             temperature=config.core_template,
83             base_url=config.base_url,
84             api_key=config.api_key
85         )
86         
87         self.data_ai_config = AIConfig(
88             model_name=config.data_model,
89             temperature=config.data_template,
90             base_url=config.base_url,
91             api_key=config.api_key
92         )
93         
94         # 创建Git配置
95         self.git_config = GitConfig(
96             repo_path=self.project_dir,
97             remote_url=config.github_remote_url or os.getenv("GIT_REMOTE"),
98             auth_token=config.github_token or os.getenv("GITHUB_TOKEN"),
99             default_branch=config.default_branch
100         )
101         
102         # 创建日志配置
103         self.log_config = LogConfig(
104             project_dir=self.project_dir,
105             issue_id=config.issue_id,
106             mode=config.mode
107         )
108         
109         # 初始化管理器
110         self.git_manager = GitManager(config=self.git_config)
111 
112         # 检出对应的分支
113         if self.config.mode == "bot":
114             try:
115                 # 重置到issue对应的分支
116                 self.git_manager.reset_to_issue_branch(self.config.issue_id)
117                 logger.info(f"成功初始化Bot模式环境，工作目录: {self.temp_dir}")
118             except Exception as e:
119                 logger.error(f"初始化Bot模式环境失败: {str(e)}")
120                 self._cleanup_environment()
121                 raise
122 
123         self.log_manager = LogManager(config=self.log_config)
124         
125         # 初始化文件记忆管理，传入log_manager
126         self.file_memory = FileMemory(
127             config=FileMemoryConfig(
128                 git_manager=self.git_manager,
129                 ai_config=self.data_ai_config,
130                 project_dir=self.project_dir,
131                 log_manager=self.log_manager
132             )
133         )
134         self.version_manager = VersionManager(
135             issue_id=config.issue_id,
136             ai_config=self.core_ai_config,
137             log_manager=self.log_manager,
138             git_manager=self.git_manager,
139             file_memory=self.file_memory
140         )
141         self.file_selector = FileSelector(
142             self.project_dir,
143             self.config.issue_id,
144             ai_config=self.core_ai_config
145         )
146 
147         # 初始化代码工程师
148         self.code_engineer_config = CodeEngineerConfig(
149             project_dir=self.project_dir,
150             ai_config=self.core_ai_config
151         )
152         self.engineer = CodeEngineer(
153             self.code_engineer_config,
154             self.log_manager,
155             Diff(self.data_ai_config)
156         )
157         
158         # 初始化聊天处理器
159         self.chat_processor = ChatProcessor(
160             ai_config=self.core_ai_config,
161             log_manager=self.log_manager,
162             config=ChatProcessorConfig(system_prompt="你是一个项目助手，负责回答关于代码库的问题。下面会给出用户的问题以及相关的项目文件信息。")
163         )
164         
165         # 初始化决策环境
166         self.decision_env = DecisionProcess(
167             ai_config=self.core_ai_config,
168             version_manager=self.version_manager
169         )
170     
171     def process_requirement(self, user_requirement: str) -> Optional[str]:
172         """
173         处理用户需求
174         
175         Args:
176             user_requirement: 用户需求
177 
178         Returns:
179             str: 处理结果的响应文本
180         """
181         try:
182 
183             current_round = self.log_manager.get_current_round()
184 
185             # 如果轮次大于1，增量更新上一轮修改的文件详细信息
186             if self.file_memory and current_round > 1:
187                 self.file_memory.update_file_details()
188                 logger.info("已更新文件详细信息")
189 
190             response = self._process_requirement_internal(user_requirement)
191             
192             # 如果是bot模式，在结束时清理临时目录
193             if self.config.mode == "bot":
194                 self._cleanup_environment()
195             
196             return response
197         except Exception as e:
198             logger.error(f"处理需求时发生错误: {str(e)}")
199             raise
200 
201 
202     def _finalize_changes(self, mode: str, comment_text: str) -> bool:
203         """
204         完成更改，在bot模式下提交并推送更改
205 
206         Args:
207             mode: 工作模式 ("client" 或 "bot")
208             comment_text: comment内容
209 
210         Returns:
211             bool: 操作是否成功
212         """
213         if mode == "bot":
214             self.git_manager.commit(f"Issues #{self.config.issue_id} - Changes by Bella-Issues-Bot")
215             self.git_manager.push()
216             self.git_manager.add_issue_comment(self.config.issue_id, comment_text)
217         return True
218         
219     def _cleanup_environment(self) -> None:
220         """
221         清理工作环境，删除临时目录
222         """
223         if self.config.mode == "bot" and self.temp_dir and os.path.exists(self.temp_dir):
224             try:
225                 # 关闭git仓库连接
226                 if hasattr(self, 'git_manager') and self.git_manager:
227                     self.git_manager.delete_local_repository()
228                 
229                 # 删除临时目录
230                 shutil.rmtree(self.temp_dir, ignore_errors=True)
231                 logger.info(f"已清理临时工作目录: {self.temp_dir}")
232             except Exception as e:
233                 logger.warning(f"清理临时目录时出错: {str(e)}")
234                 # 即使清理失败也不抛出异常，让主流程继续
235 
236     def _process_requirement_internal(self, user_requirement: str) -> Optional[str]:
237         """
238         内部处理需求的方法
239         
240         Args:
241             user_requirement: 用户需求
242             
243         Returns:
244             str: 处理结果
245         """
246         # 先通过决策环境分析需求类型
247         decision_result = self.decision_env.analyze_requirement(user_requirement)
248         
249         logger.info(f"决策结果: 是否需要修改代码={decision_result.needs_code_modification}, "
250                     f"理由={decision_result.reasoning}")
251         
252         if decision_result.needs_code_modification:
253             # 执行代码修改流程
254             response = self._run_code_generation_workflow(user_requirement)
255         else: 
256             # 执行对话流程
257             response = self._run_chat_workflow(user_requirement)
258         
259         # 如果是Bot模式且有GitHub配置，自动回复到issue
260         if self.config.mode == "bot":
261             try:
262                 self._finalize_changes(mode=self.config.mode, comment_text=response)
263                 logger.info(f"更改已经推送到远端，并添加了Issue评论")
264             except Exception as e:
265                 logger.error(f"添加Issue评论时出错: {str(e)}")
266                 
267         return response
268     
269     def _run_code_generation_workflow(self, user_requirement: str) -> Optional[str]:
270         """
271         执行代码生成流程，基于example_code_generate.py的逻辑
272         
273         Args:
274             user_requirement: 用户需求
275             
276         Returns:
277             str: 处理结果
278         """
279         logger.info("开始执行代码生成流程")
280 
281         # 确定当前版本
282         requirement, history = self.version_manager.ensure_version_and_generate_context(user_requirement)
283 
284         # 生成提示词
285         user_prompt = self._get_user_prompt(requirement, history)
286 
287         # 根据提示词修改代码
288         success, response = self.engineer.process_prompt(prompt=user_prompt)
289 
290         # 提交更改
291         if success:
292             return response
293         else:
294             self.CODE_TIMES += 1
295             if self.CODE_TIMES >= self.config.max_retry:
296                 logger.error("code workflow超过最大重试次数")
297                 return self._run_chat_workflow(user_requirement)
298             else:
299                 return self._run_code_generation_workflow(user_requirement)
300     
301     def _run_chat_workflow(self, user_requirement: str) -> Optional[str]:
302         """
303         执行聊天流程，基于example_chat_process.py的逻辑
304         
305         Args:
306             user_requirement: 用户需求
307             
308         Returns:
309             str: 处理结果
310         """
311         logger.info("开始执行聊天回复流程")
312 
313         history = self.version_manager.get_formatted_history()
314 
315         # 生成提示词
316         user_prompt = self._get_user_prompt(user_requirement, history)
317         
318         # 处理聊天请求
319         response = self.chat_processor.process_chat(user_prompt)
320 
321         if(response):
322             return response
323         else:
324             self.CHAT_TIMES += 1
325             if self.CHAT_TIMES >= self.config.max_retry:
326                 logger.error("chat workflow超过最大重试次数")
327                 return None
328             else:
329                 return self._run_chat_workflow(user_requirement)
330 
331     def _get_user_prompt(self, requirement: str, history: str) -> str:
332         # 选择文件
333         files = self.file_selector.select_files_for_requirement(requirement)
334         descriptions = FileMemory.get_selected_file_descriptions(self.project_dir, files)
335 
336         # 准备提示词数据
337         data = PromptData(
338             requirement=requirement,
339             project_dir=self.project_dir,
340             steps=history,
341             files=files,
342             file_desc=descriptions
343         )
344 
345         # 生成提示词
346         return PromptGenerator.generatePrompt(data)
347
```




```
File: README.md
1 # bella-issues-bot
2 
3 - [![Static Badge](https://img.shields.io/badge/deep-wiki-blue?style=flat-square)](https://deepwiki.com/bella-top/bella-issues-bot)
4 - [![Static Badge](https://img.shields.io/badge/Bella-support-%23C76300?style=flat-square)](https://doc.bella.top/)
5 
6 中文 | [English](./README.en.md)
7 
8 ## 项目简介
9 
10 bella-issues-bot 是一个基于人工智能的多功能代码开发助手，具备两种强大的工作模式：
11 
12 1. **个人开发助手模式**：在日常开发过程中，作为命令行工具辅助编码，帮助分析代码、生成实现、解决技术难题。
13 2. **GitHub自动化模式**：集成到GitHub工作流中，自动监控和处理项目Issues，无需人工干预即可分析需求、提出解决方案并实现代码变更。
14 
15 通过对项目结构的深入理解和强大的代码生成能力，bella-issues-bot 能够显著提高开发效率，减少重复工作，让您专注于更有创造性的任务。
16 
17 ## 主要功能
18 
19 - **需求分析**：自动理解和分解用户的功能需求，确定所需的代码修改
20 - **代码生成**：根据需求生成符合项目风格的代码，自动实现新功能或修复问题
21 - **版本管理**：与Git深度集成，支持分支创建、代码提交和拉取请求的自动管理
22 - **记忆系统**：记录项目文件描述和操作历史，提供上下文感知能力，持续改进代码质量
23 
24 ### 典型使用场景
25 
26 - **日常开发辅助**：在本地开发过程中，使用命令行工具快速生成代码、解决技术问题
27 - **项目自动化**：集成到GitHub工作流，实现Issue的自动处理和代码实现
28 - **代码文档生成**：自动分析项目文件并生成详细的功能描述
29 - **技术难题解决**：分析项目上下文后，针对性地提供解决方案
30 
31 ## 记忆与上下文管理
32 
33 bella-issues-bot 配备了强大的记忆系统，由三个核心组件构成：
34 
35 ### 记忆系统的工作流程
36 
37 1. **初始化阶段**：首次运行时，系统会扫描整个项目并为每个文件生成详细描述
38 2. **增量更新**：后续运行时，只会更新新增或修改的文件描述，提高效率
39 3. **上下文提取**：处理用户需求时，系统根据需求内容选择相关文件作为上下文
40 
41 ### 1. 日志管理 (LogManager)
42 
43 LogManager 负责记录每次交互的完整历史，包括：
44 - 系统提示词和用户需求
45 - AI响应内容
46 - 文件修改记录和差异对比
47 
48 这些日志按issue和轮次组织，支持历史追溯和问题诊断。每轮交互都会生成详细日志，便于追踪AI的决策过程和代码修改历史。
49 
50 ### 2. 版本管理 (VersionManager)
51 
52 VersionManager 提供智能的版本控制功能：
53 - 自动提取历史轮次的需求和响应
54 - 生成格式化的历史执行记录作为上下文
55 - 分析当前需求与历史需求的关系
56 - 根据需要执行版本回退操作
57 
58 系统会分析新需求与先前修改的关系，判断是否需要回滚，确保代码修改的连贯性和一致性。
59 
60 ### 3. 文件记忆 (FileMemory)
61 
62 FileMemory 模块为项目的每个文件维护详细描述：
63 - 自动生成文件功能、结构和关系描述
64 - 跟踪文件变更，更新受影响文件的描述
65 - 提供上下文相关的文件选择
66 - 支持配置忽略文件，默认包含项目的.gitignore，支持自定义添加.eng/.engignore
67 
68 这使得AI助手能够理解整个代码库的结构和功能，在修改代码时考虑到更广泛的项目上下文。
69 
70 ## 安装方法
71 
72 ### 通过 pip 安装
73 
74 ```bash
75 pip install bella-issues-bot
76 ```
77 
78 ### 从源码安装
79 
80 ```bash
81 git clone https://github.com/szl97/bella-issues-bot.git
82 cd bella-issues-bot
83 pip install -e .
84 ```
85 
86 ## 系统要求
87 
88 - Python 3.10 或更高版本（<3.13）
89 - Git 客户端（用于版本控制功能）
90 - OpenAI API 密钥（用于 AI 功能）
91 
92 ## 配置文件
93 
94 bella-issues-bot 支持多种配置方式：
95 
96 ### 环境变量配置
97 
98 工具会读取以下环境变量：
99 
100 - `OPENAI_API_KEY`: OpenAI API密钥（必需）
101 - `OPENAI_API_BASE`: OpenAI API基础URL（可选，用于自定义API端点）
102 - `GITHUB_REMOTE_URL`: GitHub远程仓库URL（可选，用于GitHub集成）
103 - `GITHUB_TOKEN`: GitHub身份验证令牌（可选，用于GitHub集成）
104 
105 ### 项目配置文件
106 
107 
108 - `.eng/system.txt`: 配置代码工程师的提示词
109 - `.eng/.engignore`: 类似于 `.gitignore`，用于指定文件记忆系统应忽略的文件
110 
111 示例 `.engignore` 文件:
112 ```
113 # 忽略所有日志文件
114 *.log
115 
116 # 忽略构建目录
117 /build/
118 /dist/
119 
120 # 忽略虚拟环境
121 /venv/
122 /.venv/
123 
124 # 忽略缓存文件
125 __pycache__/
126 *.py[cod]
127 *$py.class
128 ```
129 
130 ## 详细使用示例
131 
132 ### 0. 进入您的项目目录
133 
134 ### 1. 初始化文件记忆系统
135 
136 首次使用前，建议初始化文件记忆系统，这将帮助 AI 理解您的项目结构：
137 
138 ```bash
139 # 在项目根目录执行
140 bella-file-memory --project-dir .
141 ```
142 
143 这将分析您的项目文件并生成描述信息，存储在 `.eng/memory/file_details.txt` 中。
144 
145 ### 2. 作为个人开发助手使用
146 
147 ```bash
148 # 基本使用
149 bella-issues-bot --issue-id 123 --requirement "实现一个新的日志记录功能"
150 
151 # 使用自定义模型和温度
152 bella-issues-bot --issue-id 123 --requirement "优化文件读取性能" --core-model gpt-4o --core-temperature 0.5
153 ```
154 
155 ### 3. 设置 GitHub 工作流
156 
157 为您的项目生成 GitHub Actions 工作流配置：
158 
159 ```bash
160 # 生成默认工作流配置
161 bella-github-workflows
162 
163 # 自定义基础分支和模型
164 bella-github-workflows --base-branch develop --model gpt-4o
165 ```
166 
167 生成的工作流文件将保存在 `.github/workflows/` 目录中。
168 
169 ### 4. 使用编程 API
170 
171 ```python
172 from client.runner import run_workflow
173 
174 # 基本使用
175 run_workflow(
176     issue_id=123,
177     requirement="添加单元测试覆盖核心功能",
178     project_dir="./my_project"
179 )
180 
181 # 高级配置
182 run_workflow(
183     issue_id=123,
184     requirement="重构数据处理模块以提高性能",
185     project_dir="./my_project",
186     core_model="gpt-4o",
187     data_model="gpt-4o",
188     core_temperature=0.7,
189     data_temperature=0.5,
190     mode="client",  # 或 "bot" 用于 GitHub 自动化
191     max_retry=5
192 )
193 ```
194 
195 ## 项目结构
196 
197 ```
198 bella-issues-bot/
199 ├── core/               # 核心功能模块
200 │   ├── ai.py           # AI 助手接口
201 │   ├── file_memory.py  # 文件记忆系统
202 │   ├── git_manager.py  # Git 版本控制
203 │   └── workflow_engine.py  # 工作流引擎
204 ├── client/             # 客户端接口
205 │   ├── terminal.py     # 命令行界面
206 │   ├── file_memory_client.py  # 文件记忆客户端
207 │   └── github_workflow_generator.py  # GitHub 工作流生成器
208 └── examples/           # 使用示例
209 ```
210
```




```
File: README.en.md
1 # bella-issues-bot
2 
3 - [![Static Badge](https://img.shields.io/badge/deep-wiki-blue?style=flat-square)](https://deepwiki.com/bella-top/bella-issues-bot)
4 - [![Static Badge](https://img.shields.io/badge/Bella-support-%23C76300?style=flat-square)](https://doc.bella.top/)
5 
6 English | [中文](./README.md)
7 
8 ## Project Overview
9 
10 bella-issues-bot is an AI-powered multifunctional code development assistant that operates in two powerful modes:
11 
12 1. **Personal Development Assistant Mode**: Acts as a command-line tool during daily development, helping analyze code, generate implementations, and solve technical challenges.
13 2. **GitHub Automation Mode**: Integrates into GitHub workflows, automatically monitoring and handling project issues, analyzing requirements, proposing solutions, and implementing code changes without manual intervention.
14 
15 Through its deep understanding of project structure and powerful code generation capabilities, bella-issues-bot significantly improves development efficiency, reduces repetitive work, and lets you focus on more creative tasks.
16 
17 ## Key Features
18 
19 - **Requirement Analysis**: Automatically understands and breaks down user requirements to determine necessary code changes
20 - **Code Generation**: Generates code that matches project style, automatically implementing new features or fixing issues
21 - **Version Control**: Deep Git integration, supporting automated branch creation, code commits, and pull request management
22 - **Memory System**: Records project file descriptions and operation history, providing context-aware capabilities and continuous code quality improvement
23 
24 ### Typical Use Cases
25 
26 - **Daily Development Support**: Use command-line tools for quick code generation and technical problem-solving
27 - **Project Automation**: Integrate with GitHub workflows for automated issue handling and code implementation
28 - **Code Documentation Generation**: Automatically analyze project files and generate detailed functional descriptions
29 - **Technical Problem Resolution**: Provide targeted solutions after analyzing project context
30 
31 ## Memory and Context Management
32 
33 bella-issues-bot features a powerful memory system consisting of three core components:
34 
35 ### Memory System Workflow
36 
37 1. **Initialization Phase**: On first run, the system scans the entire project and generates detailed descriptions for each file
38 2. **Incremental Updates**: Subsequently, only updates descriptions for new or modified files, improving efficiency
39 3. **Context Extraction**: When processing user requirements, the system selects relevant files as context based on requirement content
40 
41 ### 1. Log Management (LogManager)
42 
43 LogManager records complete interaction history, including:
44 - System prompts and user requirements
45 - AI responses
46 - File modification records and diff comparisons
47 
48 Logs are organized by issue and iteration, supporting historical tracking and problem diagnosis.
49 
50 ### 2. Version Management (VersionManager)
51 
52 VersionManager provides intelligent version control features:
53 - Automatically extracts requirements and responses from historical iterations
54 - Generates formatted execution history as context
55 - Analyzes relationships between current and historical requirements
56 - Performs version rollbacks as needed
57 
58 ### 3. File Memory (FileMemory)
59 
60 FileMemory module maintains detailed descriptions for each project file:
61 - Automatically generates file functionality, structure, and relationship descriptions
62 - Tracks file changes and updates affected file descriptions
63 - Provides context-aware file selection
64 - Supports ignored files configuration, includes project's .gitignore by default, and supports custom .eng/.engignore
65 
66 ## Installation
67 
68 ### Via pip
69 
70 ```bash
71 pip install bella-issues-bot
72 ```
73 
74 ### From Source
75 
76 ```bash
77 git clone https://github.com/szl97/bella-issues-bot.git
78 cd bella-issues-bot
79 pip install -e .
80 ```
81 
82 ## System Requirements
83 
84 - Python 3.10 or higher (< 3.13)
85 - Git client (for version control features)
86 - OpenAI API key (for AI functionality)
87 
88 ## Configuration
89 
90 bella-issues-bot supports multiple configuration methods:
91 
92 ### Environment Variables
93 
94 The tool reads the following environment variables:
95 
96 - `OPENAI_API_KEY`: OpenAI API key (required)
97 - `OPENAI_API_BASE`: OpenAI API base URL (optional, for custom API endpoints)
98 - `GITHUB_REMOTE_URL`: GitHub repository URL (optional, for GitHub integration)
99 - `GITHUB_TOKEN`: GitHub authentication token (optional, for GitHub integration)
100 
101 ### Project Configuration Files
102 
103 - `.eng/system.txt`: Configure code engineer prompts
104 - `.eng/.engignore`: Similar to `.gitignore`, specifies files to be ignored by the memory system
105 
106 Example `.engignore` file:
107 ```
108 # Ignore all log files
109 *.log
110 
111 # Ignore build directories
112 /build/
113 /dist/
114 
115 # Ignore virtual environments
116 /venv/
117 /.venv/
118 
119 # Ignore cache files
120 __pycache__/
121 *.py[cod]
122 *$py.class
123 ```
124 
125 For detailed usage examples and project structure, please refer to the QUICK-START.md guide.
```




# 用户需求

为LogManager写一个example