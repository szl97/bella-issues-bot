[
  {
    "file_name": "examples/example_version_manager.py",
    "content": "diff\n--- /dev/null\n+++ examples/example_version_manager.py\n@@ -0,0 +1,132 @@\n+\"\"\"\n+本示例展示如何使用VersionManager进行代码版本管理和回滚操作\n+\n+版本管理是代码生成中的重要环节，能够支持：\n+1. 历史记录的检索和格式化展示\n+2. 对用户需求进行分析，判断是否需要回滚\n+3. 执行代码版本回滚\n+4. 基于不同版本进行代码生成\n+\"\"\"\n+\n+import logging\n+import os\n+\n+from dotenv import load_dotenv\n+\n+from core.ai import AIConfig\n+from core.code_engineer import CodeEngineerConfig, CodeEngineer\n+from core.diff import Diff\n+from core.file_memory import FileMemory, FileMemoryConfig\n+from core.git_manager import GitManager, GitConfig\n+from core.log_config import setup_logging\n+from core.log_manager import LogManager, LogConfig\n+from core.prompt_generator import PromptGenerator, PromptData\n+from core.version_manager import VersionManager\n+\n+\n+def main():\n+    \"\"\"主函数：演示VersionManager的使用流程\"\"\"\n+    setup_logging(log_level=logging.INFO)\n+    # 加载环境变量\n+    load_dotenv()\n+    \n+    # 创建工作目录\n+    project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../.\"))\n+\n+    # 设置issue_id (在实际应用中，这通常是从命令行参数或环境变量获取)\n+    issue_id = 10\n+    \n+    # 初始化日志管理器\n+    print(\"1. 初始化日志管理器\")\n+    log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)\n+    log_manager = LogManager(config=log_config)\n+    current_round = log_manager.get_current_round()\n+    print(f\"   当前轮次: {current_round}\")\n+    \n+    # 初始化Git管理器\n+    print(\"\\n2. 初始化Git管理器\")\n+    git_config = GitConfig(\n+        repo_path=project_dir,\n+        # 可以在这里设置远程仓库URL和认证令牌\n+        # remote_url=\"https://github.com/yourusername/yourrepo.git\",\n+        # auth_token=os.getenv(\"GITHUB_TOKEN\")\n+    )\n+    git_manager = GitManager(config=git_config)\n+    \n+    # 初始化AI助手\n+    print(\"\\n3. 初始化AI配置\")\n+    ai_config = AIConfig(\n+        model_name=\"gpt-4o\",  # 根据需要修改模型名称\n+        temperature=0.7\n+    )\n+    \n+    # 初始化文件记忆管理器（如果需要）\n+    file_memory = None\n+    if current_round > 1:\n+        print(\"\\n4. 初始化文件记忆管理器\")\n+        file_memory = FileMemory(config=FileMemoryConfig(\n+            git_manager=git_manager, \n+            ai_config=ai_config, \n+            project_dir=project_dir,\n+            log_manager=log_manager\n+        ))\n+    \n+    # 初始化版本管理器\n+    print(\"\\n5. 初始化版本管理器\")\n+    version_manager = VersionManager(\n+        issue_id=issue_id, \n+        ai_config=ai_config,\n+        log_manager=log_manager, \n+        git_manager=git_manager,\n+        file_memory=file_memory\n+    )\n+    \n+    # 示例需求\n+    current_requirement = '''\n+    添加一个新功能：为版本管理器添加导出历史记录为JSON的功能。\n+    '''\n+    print(f\"\\n6. 当前需求: {current_requirement}\")\n+    \n+    # 调用版本管理器处理需求\n+    print(\"\\n7. 处理需求并获取历史记录\")\n+    processed_requirement, history = version_manager.ensure_version_and_generate_context(current_requirement)\n+    \n+    # 输出处理后的需求和历史记录\n+    print(f\"\\n处理后的需求: {processed_requirement}\")\n+    print(f\"\\n历史记录概览: {history[:200]}...\" if len(history) > 200 else f\"\\n历史记录: {history}\")\n+    \n+    # 展示如何手动回滚到特定版本\n+    if current_round > 1:\n+        print(\"\\n8. 演示版本回滚功能\")\n+        print(\"   注意: 此处只是演示，实际不执行回滚操作\")\n+        print(f\"   要回滚到轮次 1，您可以使用以下代码:\")\n+        print(\"   success = version_manager._rollback_to_version(1)\")\n+        \n+        # 获取格式化的历史记录\n+        print(\"\\n9. 获取格式化的历史记录\")\n+        formatted_history = version_manager.get_formatted_history()\n+        print(f\"   历史记录长度: {len(formatted_history)} 字符\")\n+        print(f\"   历史记录预览: {formatted_history[:150]}...\" if len(formatted_history) > 150 else formatted_history)\n+        \n+    # 使用版本管理器分析是否需要回滚\n+    print(\"\\n10. 分析是否需要回滚\")\n+    test_requirement = '''\n+    之前实现的版本管理功能有严重bug，请回滚到上一个轮次，重新实现版本管理功能。\n+    '''\n+    print(f\"    测试需求: {test_requirement}\")\n+    \n+    if current_round > 1:\n+        print(\"    调用version_manager._analyze_rollback_need分析是否需要回滚\")\n+        print(\"    注意: 此处只是演示，不执行实际的分析操作\")\n+        # rollback_needed, target_round, integrated_req, reasoning = version_manager._analyze_rollback_need(test_requirement)\n+        # print(f\"    分析结果: 需要回滚={rollback_needed}, 目标轮次={target_round}\")\n+        # print(f\"    回滚原因: {reasoning[:100]}...\" if reasoning and len(reasoning) > 100 else reasoning)\n+    else:\n+        print(\"    当前轮次为1，无法进行回滚分析\")\n+\n+    print(\"\\n示例完成！\")\n+\n+\n+if __name__ == \"__main__\":\n+    try:\n+        main()\n+    except Exception as e:\n+        logging.error(f\"运行示例时发生错误: {str(e)}\")\n+        raise\n\n",
    "file_content": "",
    "is_create": true,
    "is_modify": false,
    "is_delete": false
  },
  {
    "file_name": "examples/advanced/version_rollback_example.py",
    "content": "diff\n--- /dev/null\n+++ examples/advanced/version_rollback_example.py\n@@ -0,0 +1,95 @@\n+\"\"\"\n+高级示例：版本回滚操作\n+\n+此示例展示如何在生产环境中使用VersionManager进行版本回滚操作，\n+包括自动分析和手动回滚两种方式。\n+\"\"\"\n+\n+import logging\n+import os\n+from typing import Optional, Tuple\n+\n+from dotenv import load_dotenv\n+\n+from core.ai import AIConfig\n+from core.git_manager import GitManager, GitConfig\n+from core.log_config import setup_logging\n+from core.log_manager import LogManager, LogConfig\n+from core.version_manager import VersionManager\n+\n+\n+def analyze_rollback_need(version_manager: VersionManager, requirement: str) -> Tuple[bool, Optional[int], Optional[str], Optional[str]]:\n+    \"\"\"\n+    使用AI分析是否需要回滚到特定版本\n+    \n+    Args:\n+        version_manager: 版本管理器实例\n+        requirement: 用户需求\n+        \n+    Returns:\n+        Tuple[bool, Optional[int], Optional[str], Optional[str]]: \n+        (是否需要回滚, 目标轮次, 整合后的需求, 分析原因)\n+    \"\"\"\n+    return version_manager._analyze_rollback_need(requirement)\n+\n+\n+def execute_rollback(version_manager: VersionManager, target_round: int) -> bool:\n+    \"\"\"\n+    执行版本回滚操作\n+    \n+    Args:\n+        version_manager: 版本管理器实例\n+        target_round: 目标轮次\n+        \n+    Returns:\n+        bool: 回滚是否成功\n+    \"\"\"\n+    return version_manager._rollback_to_version(target_round)\n+\n+\n+# 主程序\n+def main():\n+    setup_logging(log_level=logging.INFO)\n+    load_dotenv()\n+    \n+    # 设置基本配置\n+    project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../.\"))\n+    issue_id = 10  # 使用一个示例issue_id\n+    \n+    # 初始化必要组件\n+    log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)\n+    log_manager = LogManager(config=log_config)\n+    \n+    git_config = GitConfig(repo_path=project_dir)\n+    git_manager = GitManager(config=git_config)\n+    \n+    ai_config = AIConfig(model_name=\"gpt-4o\", temperature=0.7)\n+    \n+    # 初始化版本管理器\n+    version_manager = VersionManager(\n+        issue_id=issue_id, \n+        ai_config=ai_config,\n+        log_manager=log_manager, \n+        git_manager=git_manager\n+    )\n+    \n+    # 示例用户需求（包含回滚请求）\n+    user_requirement = \"\"\"\n+    上一轮的代码实现有严重问题，请回滚到轮次1并重新实现特性X。\n+    我们需要确保新实现解决了之前遇到的性能瓶颈。\n+    \"\"\"\n+    \n+    # 分析是否需要回滚\n+    print(f\"分析需求是否需要回滚: {user_requirement[:50]}...\")\n+    rollback_needed, target_round, integrated_req, reasoning = analyze_rollback_need(version_manager, user_requirement)\n+    \n+    print(f\"分析结果: 需要回滚={rollback_needed}, 目标轮次={target_round}\")\n+    print(f\"分析原因: {reasoning[:100]}...\" if reasoning and len(reasoning) > 100 else reasoning)\n+    \n+    # 如果需要回滚，执行回滚操作\n+    if rollback_needed and target_round is not None:\n+        print(f\"执行回滚到轮次 {target_round}\")\n+        success = execute_rollback(version_manager, target_round)\n+        print(f\"回滚{'成功' if success else '失败'}\")\n+\n+\n+if __name__ == \"__main__\":\n+    main()\n\n",
    "file_content": "",
    "is_create": true,
    "is_modify": false,
    "is_delete": false
  },
  {
    "file_name": "requirements.txt",
    "content": "diff\n--- requirements.txt\n+++ requirements.txt\n@@ -1,5 +1,6 @@\n langchain==0.1.0\n langchain-openai==0.0.5\n+langchain-core>=0.1.0\n python-dotenv==1.0.0\n gitpython==3.1.40\n pydantic==2.5.2\n\n",
    "file_content": "",
    "is_create": true,
    "is_modify": false,
    "is_delete": false
  }
]