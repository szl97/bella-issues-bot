# 项目文件描述


- core/version_manager.py: 版本管理模块，负责代码生成的版本控制、历史追踪和回退。包含VersionManager类，提供历史轮次提取、格式化历史记录、版本回退分析和执行功能。与GitManager和LogManager交互，为AI助手提供版本回退工具。

- core/log_manager.py: 管理代码生成日志的存储和检索。包含LogManager类，用于存档系统提示词、用户提示词、AI响应等内容，支持按issue和轮次组织日志。提供archive_logs和get_issue_log_entries等方法，记录代码生成过程。

- core/workflow_engine.py: 工作流引擎核心模块，协调版本管理、日志管理和AI交互。包含WorkflowEngine类作为主要控制器，支持client和bot两种工作模式。整合了代码工程师、聊天处理器、文件记忆、Git管理等多个组件，提供process_requirement方法处理用户需求，是整个系统的核心调度中心。

- examples/example_workflow.py: WorkflowEngine使用示例，演示如何配置和初始化工作流引擎处理用户需求。创建WorkflowEngineConfig配置，设置项目目录、模型参数等，调用process_requirement方法处理需求。作为框架使用的入门示例。

- examples/example_code_generate.py: 代码生成流程示例，展示如何使用CodeEngineer处理代码修改需求。演示了从需求分析到代码生成和提交的完整流程，包含main函数作为入口点。

- examples/example_terminal.py: 展示如何以编程方式运行工作流的示例文件。包含example_run函数，演示了如何使用client.runner中的run_workflow函数处理简单需求。同时提供了命令行运行的示例说明。

- examples/advanced/custom_workflow.py: 自定义工作流处理程序，展示如何将bella-issues-bot集成到自定义应用中。包含preprocess_requirement和postprocess_response两个关键函数，分别用于需求预处理和响应后处理。主程序读取需求文件、进行预处理、调用run_workflow执行工作流，最后进行后处理。

- client/runner.py: WorkflowEngine的编程API，提供在Python脚本中使用的简化接口。包含run_workflow函数，支持统一的模型和温度设置，以及各种配置选项。

- client/cli.py: WorkflowEngine的命令行接口，提供解析命令行参数并运行引擎的功能。包含parse_args、get_requirement_text和build_config_from_args函数，支持配置项目路径、问题ID、模型参数、温度设置和操作模式等选项。

- README.md: bella-issues-bot项目的中文README文件，详细介绍了项目简介、主要功能、记忆系统（日志管理、版本管理、文件记忆）、安装方法、配置选项和详细使用示例，还包含项目结构说明，全面展示了这个AI代码开发助手的功能和用法。

- client/README.md: WorkflowEngine客户端文档，详细介绍了系统的记忆与上下文管理机制（日志管理、版本管理、文件记忆），支持的工作模式（客户端和机器人模式），以及命令行和编程API的使用方法和配置选项。


# 文件内容



```
File: core/version_manager.py
1 """
2 版本管理模块，处理代码生成的版本控制、历史追踪和回退功能。
3 
4 该模块提供了以下功能:
5 1. 提取历史轮次的日志信息
6 2. 格式化历史执行记录用于AI参考
7 3. 分析用户需求，决定是否需要版本回退
8 4. 执行Git版本回退操作
9 5. 为AI助手提供版本回退工具
10 """
11 
12 import os
13 from dataclasses import dataclass
14 from typing import List, Tuple, Optional
15 
16 from langchain_core.tools import Tool, StructuredTool
17 from pydantic import BaseModel, Field
18 
19 from core.ai import AIConfig, AIAssistant
20 from core.git_manager import GitManager
21 from core.log_config import get_logger
22 from core.log_manager import LogManager
23 from core.prompt_generator import PromptGenerator
24 
25 logger = get_logger(__name__)
26 
27 @dataclass
28 class VersionInfo:
29     """存储特定版本的信息"""
30     issue_id: int
31     round_num: int
32     requirement: str
33     agent_response: str
34     modified_files: List[str] = None
35 
36 
37 class VersionManager:
38     """管理代码生成的版本信息，支持版本回退和需求整合"""
39 
40     def __init__(self, issue_id: int, ai_config: AIConfig, log_manager: LogManager, git_manager: GitManager, file_memory=None):
41         """
42         初始化版本管理器
43         
44         Args:
45             issue_id: GitHub issue编号
46             ai_config: AI配置
47             log_manager: 日志管理器实例 
48             git_manager: Git管理器实例
49             file_memory: 文件内存管理器实例(可选)
50         """
51         self.ai_assistant = AIAssistant(config=ai_config, tools=[self._create_version_manager_tool()])
52         self.file_memory = file_memory
53         self.log_manager = log_manager
54         self.git_manager = git_manager
55         self.current_issue_id = issue_id
56         self.current_round_num = log_manager.get_current_round()
57 
58     def ensure_version_and_generate_context(self, original_requirement: str) -> tuple[str, str]:
59         requirement = None
60         if self.current_round_num > 1 :
61             rollback, rollback_num, requirement, reasoning = self._analyze_rollback_need(original_requirement)
62         requirement = original_requirement if requirement is None else requirement
63         history = self.get_formatted_history()
64         return requirement, history
65 
66     
67     def _extract_history(self) -> List[VersionInfo]:
68         """
69         提取当前issue的历史版本信息
70             
71         Returns:
72             List[VersionInfo]: 历史版本信息列表
73         """
74         # 获取所有轮次的日志条目
75         log_entries = self.log_manager.get_issue_log_entries()
76         
77         # 提取每轮的需求和响应
78         version_info_list = []
79         for entry in log_entries:
80             try:
81                 # 从用户提示中提取需求
82                 extracted_info = PromptGenerator.extractInfo(entry.prompt)
83                 requirement = extracted_info.requirement
84                 
85                 # 创建版本信息
86                 version_info = VersionInfo(
87                     issue_id=self.current_issue_id,
88                     round_num=entry.round_num,
89                     requirement=requirement,
90                     agent_response=entry.response,
91                     modified_files=entry.modified_files
92                 )
93                 version_info_list.append(version_info)
94                 
95             except Exception as e:
96                 logger.error(f"提取轮次 {entry.round_num} 的信息时出错: {str(e)}")
97         
98         return version_info_list
99 
100     def get_formatted_history(self) -> str:
101         """
102         获取格式化的历史执行记录
103         
104         Args:
105             
106         Returns:
107             str: 格式化的历史执行记录
108         """
109         history = self._extract_history()
110         formatted_history = []
111         
112         for version in history:
113             formatted_history.append(f"【round_{version.round_num}】")
114             formatted_history.append(f"requirement: \n{version.requirement}")
115             
116             # 简化AI响应，避免历史记录过长
117             formatted_history.append(f"agent_response: \n{version.agent_response}")
118             formatted_history.append("")  # 添加空行分隔
119         return "\n".join(formatted_history)
120 
121     def _analyze_rollback_need(self,
122                               current_requirement: str) -> Tuple[bool, Optional[int], Optional[str], Optional[str]]:
123         """
124         分析是否需要版本回退
125         
126         Args:
127             current_requirement: 当前用户需求
128             
129         Returns:
130             Tuple[bool, int, str, str]: (是否需要回退, 回退到的轮次, 整合后的需求，决策的原因)
131         """
132         # 获取历史记录
133         history = self.get_formatted_history()
134         
135         # 构建提示词
136         prompt = f"""
137 # 角色
138 你是一位资深程序员，现在在处理用户的issues，请分析本次用户提出的需求和历史执行记录，判断之前提交的代码是否需要版本回退。并调用工具完成版本的创建。
139 
140 #注意
141 需要重置的轮次如果就是上一个轮次，那么就是不需要回退。
142 
143 ##需求回退的情况举例
144 - 最后一个round是5，假如你认为round4和round5的改动极其不符合，会影响用户需求的实现，那么就需要回滚4和5，此次的需求基于round3修改，target_round为1
145 - 最后一个round是4，假如你认为之前的所有修改都极其不符合用户需求或错误，重新改更有利，那么用户此次的需求应该基于原始代码修改，那么就需要回滚所有改动，target_round为0
146 
147 ##不需要回滚的情况举例
148 - 最后一个round是5，假如你认为用户的此次需求，在round5的代码上改动即可，那么就可以不回滚，直接修改
149 
150 # 历史执行记录
151 {history}
152 
153 # 当前用户需求
154 {current_requirement}
155 
156 
157 #执行步骤
158 ##工具参数分析
159 你需要调用 version_manager 工具来处理问题，请请根据上述信息分析以下问题，
160 1. 是否需要回退到某个特定版本? 如果需要，则调用工具时的参数 need_rollback 为 True
161 2. 如果需要回退，应该回退到哪个round?  调用工具时的参数，大于等于0，如果全部回滚则设置为0
162 3. 如果需要回退，当前需求的信息是否完整？需要把回退到的round之后的round需求与当前需求结合，作为补充信息吗? 如果需要结合，则将重写后的本轮需求，作为integrated_requirement参数；如果不需要则不需要此参数。
163 4. 做出这个决策的原因是什么？调用工具时，作为reasoning参数
164 
165 ##工具执行
166 根据得到的参数，调用version_manager。无论是否需要rollback必须调用工具执行任务，完成当前版本的创建。
167 
168 """
169 
170         # 发送给AI进行分析
171         response = self.ai_assistant.generate_response(prompt, use_tools=True)
172 
173         return response if response else (False, 0, current_requirement)
174 
175     def _rollback_to_version(self, target_round: int) -> bool:
176         """
177         执行基于文件的版本回退
178         
179         Args:
180             target_round: 目标轮次
181             
182         Returns:
183             bool: 回退是否成功
184         """
185         try:
186             # 获取目标轮次的日志条目
187             log_entries = self.log_manager.get_issue_log_entries(include_diff=True)
188             
189             if not log_entries:
190                 logger.error("找不到任何日志条目")
191                 return False
192             
193             # 获取当前轮次到目标轮次之间的所有轮次记录，按轮次降序排列（从最新到最旧）
194             entries_to_rollback = sorted(
195                 [entry for entry in log_entries if entry.round_num > target_round],
196                 key=lambda entry: entry.round_num,
197                 reverse=True
198             )
199             
200             if not entries_to_rollback:
201                 logger.info(f"当前已经是轮次 {target_round} 或更早，无需回滚")
202                 return True
203             
204             # 依次回滚每一轮的修改
205             import os
206             project_dir = self.log_manager.config.project_dir
207             
208             for entry in entries_to_rollback:
209                 logger.info(f"正在回滚轮次 {entry.round_num} 的修改...")
210                 
211                 if not entry.modified_files:
212                     logger.info(f"轮次 {entry.round_num} 没有文件修改，跳过")
213                     continue
214                 
215                 # 对每个修改的文件进行回滚
216                 for diff_info in entry.modified_files:
217                     file_path = os.path.join(project_dir, diff_info.file_name)
218                     
219                     if diff_info.is_create:
220                         # 如果是创建操作，则删除该文件
221                         if os.path.exists(file_path):
222                             os.remove(file_path)
223                             logger.info(f"删除文件 {diff_info.file_name}，回滚轮次 {entry.round_num} 的创建操作")
224                     
225                     elif diff_info.is_modify:
226                         # 如果是修改操作，则恢复到修改前的内容
227                         if diff_info.file_content is not None:
228                             os.makedirs(os.path.dirname(file_path), exist_ok=True)
229                             with open(file_path, "w", encoding="utf-8") as f:
230                                 f.write(diff_info.file_content)
231                             logger.info(f"恢复文件 {diff_info.file_name} 到轮次 {entry.round_num} 修改前的状态")
232                         else:
233                             logger.warning(f"文件 {diff_info.file_name} 没有保存修改前的内容，无法回滚")
234                     
235                     elif diff_info.is_delete:
236                         # 如果是删除操作，则恢复文件
237                         if diff_info.file_content is not None:
238                             os.makedirs(os.path.dirname(file_path), exist_ok=True)
239                             with open(file_path, "w", encoding="utf-8") as f:
240                                 f.write(diff_info.file_content)
241                             logger.info(f"恢复文件 {diff_info.file_name}，回滚轮次 {entry.round_num} 的删除操作")
242                         else:
243                             logger.warning(f"文件 {diff_info.file_name} 没有保存删除前的内容，无法回滚")
244 
245             self.log_manager.rollback_logs(target_round)
246             logger.info(f"成功回滚到轮次 {target_round}")
247             return True
248             
249         except Exception as e:
250             logger.error(f"文件版本回退失败: {str(e)}")
251             return False
252 
253     def _rollback_to_version_git(self, target_round: int) -> bool:
254         """
255         执行版本回退
256         
257         Args:
258             target_round: 目标轮次
259             
260         Returns:
261             bool: 回退是否成功
262         """
263         try:
264             # 构建目标分支名
265             target_branch = f"bella-bot-issues-{self.current_issue_id}-{target_round}"
266             return self.git_manager.reset_to(target_branch)
267             
268         except Exception as e:
269             logger.error(f"Git版本回退失败: {str(e)}")
270             return False
271 
272     class _VersionManagerToolSchema(BaseModel):
273         need_rollback: bool = Field(
274             ...,
275             examples=[True, False],
276             description="是否需要回退版本"
277         )
278         target_round: Optional[int] = Field(
279             None,
280             examples=[0,1,2,3,4],
281             description="要回滚到的目标轮次，只有need_rollback为True时需要且必须.0代表需要全部回滚。"
282         )
283         integrated_requirement: Optional[str] = Field(
284             None,
285             description="整合后的需求，只有need_rollback为True且需要重写需求时需要"
286         )
287         reasoning: Optional[str] = Field(
288             None,
289             description="做这个出决策的原因"
290         )
291 
292     def _create_version_manager_tool(self) -> StructuredTool:
293         """
294         版本管理工具，供AI助手使用
295             
296         Returns:
297             Tool: 版本管理工具
298         """
299         def version_manager_tool(need_rollback: bool,
300                                           target_round: Optional[int] = None,
301                                           integrated_requirement: Optional[str] = None,
302                                           reasoning: Optional[str] = None) -> Tuple[str, Optional[int], Optional[str], Optional[str]]:
303             """
304             决定是否回退版本并执行回退
305             
306             Args:
307                 need_rollback:是否需要回退,
308                 target_round：回退到的轮次,
309                 integrated_requirement： 整合后的需求
310                 reasoning: 做出决策的原因
311                 
312             Returns:
313                 str: 执行结果
314             """
315             
316             if need_rollback and target_round is not None:
317                 success = self._rollback_to_version(target_round)
318                 if(success) :
319                     return (True, target_round, integrated_requirement, reasoning)
320                 else:
321                     logger.warning(f"版本回退失败:issues:{self.current_issue_id},target:{target_round},integrated_requirement:{integrated_requirement}")
322             return (False, 0, None, reasoning)
323         
324         return StructuredTool.from_function(
325             name="version_rollback_manager",
326             description="用于决定当前项目版本的工具，如果 need_rollback 为True，则根据target_round和integrated_requirement进行版本回退；如果need_rollback为False则保持当前版本",
327             func=version_manager_tool,
328             return_direct=True,
329             args_schema=self._VersionManagerToolSchema
330         )
331
```




```
File: core/log_manager.py
1 import datetime
2 import os
3 import json
4 import shutil
5 from dataclasses import dataclass, field
6 from typing import List, Optional
7 from pydantic import BaseModel
8 
9 from core.diff import DiffInfo
10 from core.log_config import get_logger
11 
12 logger = get_logger(__name__)
13 
14 @dataclass
15 class LogConfig:
16     """日志管理配置"""
17 
18     project_dir: str
19     issue_id: int
20     mode: str = "client" # ["client", "bot"]
21 
22 
23 class LogEntry(BaseModel):
24     """存储单次代码生成日志的数据类"""
25     issue_id: int
26     round_num: int
27     sys_prompt: str
28     prompt: str
29     response: str
30     timestamp: str = datetime.datetime.now().isoformat()
31     log_path: str = ""
32     modified_files: List[DiffInfo] = []
33 
34 
35 class LogManager:
36     """管理代码生成日志的存档和检索"""
37     base_dir: str = ".eng"
38     logs_base_dir: str = "memory"
39     rollback_dir: str = "rollback"
40 
41     def __init__(self, config: LogConfig):
42         """
43         初始化日志管理器
44 
45         Args:
46             config: LogConfig实例，包含必要的配置信息
47         """
48         self.config = config
49         self.issue_id = self.config.issue_id
50 
51         
52         # 根据模式选择存储目录
53         if self.config.mode == "bot":
54             logs_dir = "issues"
55         else:
56             logs_dir = "queries"
57             
58         # 构建完整的日志存储路径
59         self.logs_path = os.path.join(
60             self.config.project_dir, 
61             self.base_dir,
62             self.logs_base_dir,
63             logs_dir)
64         self.issues_path = os.path.join(
65             self.logs_path, "#" + str(self.issue_id)
66         )
67 
68         self.rollback_path = os.path.join(
69             self.logs_path, "#" + str(self.issue_id), self.rollback_dir
70         )
71 
72         # 初始化当前轮次
73         self.current_round = self._get_next_round()
74 
75         # 确保必要的目录存在
76         os.makedirs(self.issues_path, exist_ok=True)
77         os.makedirs(self.rollback_path, exist_ok=True)
78 
79         # 定义日志文件名常量
80         self.SYS_PROMPT_FILE = "system_prompt.txt"
81         self.USER_PROMPT_FILE = "user_prompt.txt"
82         self.AI_RESPONSE_FILE = "ai_response.txt"
83         self.TIMESTAMP_FILE = "timestamp.txt"
84         self.MODIFIED_FILES_FILE = "modified_files.txt"
85 
86     def archive_logs(self, sys_prompt: str, prompt: str, response: str, diff_infos: List[DiffInfo] = None) -> str:
87         """
88         将代码生成日志存档到指定的目录
89 
90         Args:
91             diff_infos: 文件的修改信息
92             sys_prompt: 系统提示词
93             prompt: 用户提示词
94             response: AI响应
95 
96         Returns:
97             str: 存档目录的路径
98         """
99         # 获取下一个轮次号
100 
101         round_num = self.current_round
102 
103         # 获取当前时间戳
104         timestamp = datetime.datetime.now().isoformat()
105         
106         # 创建轮次目录
107         round_dir = os.path.join(self.issues_path, f"round_{round_num}")
108         os.makedirs(round_dir, exist_ok=True)
109         
110         # 保存系统提示词
111         with open(os.path.join(round_dir, self.SYS_PROMPT_FILE), "w", encoding="utf-8") as f:
112             f.write(sys_prompt)
113         
114         # 保存用户提示词
115         with open(os.path.join(round_dir, self.USER_PROMPT_FILE), "w", encoding="utf-8") as f:
116             f.write(prompt)
117         
118         # 保存AI响应
119         with open(os.path.join(round_dir, self.AI_RESPONSE_FILE), "w", encoding="utf-8") as f:
120             f.write(response)
121             
122         # 保存时间戳
123         with open(os.path.join(round_dir, self.TIMESTAMP_FILE), "w", encoding="utf-8") as f:
124             f.write(timestamp)
125 
126         # 保存修改的文件列表
127         if diff_infos:
128             # 使用 Pydantic 的 dict 方法进行序列化
129             diff_dicts = [diff.dict() for diff in diff_infos]
130                 
131             # 序列化为 JSON 并保存
132             with open(os.path.join(round_dir, self.MODIFIED_FILES_FILE), "w", encoding="utf-8") as f:
133                 json.dump(diff_dicts, f, ensure_ascii=False, indent=2)
134             logger.info(f"保存了 {len(diff_infos)} 个修改的文件记录")
135         
136         # 记录日志
137         logger.info(f"已将日志存档至: {round_dir}")
138         
139         # 返回存档目录的路径
140         return round_dir
141 
142     def _get_next_round(self) -> int:
143         """
144         获取下一个轮次号
145 
146         Returns:
147             int: 下一个轮次号
148         """
149         issue_path = self.issues_path
150         if not os.path.exists(issue_path):
151             return 1
152 
153         existing_rounds = [
154             int(d[6:])
155             for d in os.listdir(issue_path)
156             if os.path.isdir(os.path.join(issue_path, d)) and (d[6:]).isdigit()
157         ]
158 
159         return max(existing_rounds, default=0) + 1
160 
161     def get_current_round(self) -> int:
162         return self.current_round
163         
164     def get_issue_log_entries(self, include_diff: bool = False) -> List[LogEntry]:
165         """
166         获取当前issue的所有轮次的日志条目
167 
168         Returns:
169             List[LogEntry]: 日志条目列表，按轮次排序
170         """
171         
172         log_entries = []
173 
174         issue_dir = self.issues_path
175         # 遍历所有轮次目录
176         for dir_name in os.listdir(issue_dir):
177             if not dir_name.startswith("round_"):
178                 continue
179                 
180             try:
181                 round_num = int(dir_name[6:])  # 提取轮次号
182                 round_dir = os.path.join(issue_dir, dir_name)
183                 
184                 # 读取系统提示词
185                 sys_prompt_path = os.path.join(round_dir, self.SYS_PROMPT_FILE)
186                 with open(sys_prompt_path, "r", encoding="utf-8") as f:
187                     sys_prompt = f.read()
188                 
189                 # 读取用户提示词
190                 user_prompt_path = os.path.join(round_dir, self.USER_PROMPT_FILE)
191                 with open(user_prompt_path, "r", encoding="utf-8") as f:
192                     prompt = f.read()
193                 
194                 # 读取AI响应
195                 ai_response_path = os.path.join(round_dir, self.AI_RESPONSE_FILE)
196                 with open(ai_response_path, "r", encoding="utf-8") as f:
197                     response = f.read()
198                     
199                 # 读取修改的文件列表(如果存在)
200                 modified_files = []
201                 if include_diff:
202                     modified_files_path = os.path.join(round_dir, self.MODIFIED_FILES_FILE)
203                     if os.path.exists(modified_files_path):
204                         try:
205                             with open(modified_files_path, "r", encoding="utf-8") as f:
206                                 diff_dicts = json.load(f)
207                                 
208                                 # 将字典转换回 DiffInfo 对象
209                                 modified_files = [DiffInfo(**diff_dict) for diff_dict in diff_dicts]
210                         except Exception as e:
211                             logger.error(f"读取修改文件列表失败: {str(e)}")
212                     
213                 # 读取时间戳
214                 timestamp_path = os.path.join(round_dir, self.TIMESTAMP_FILE)
215                 timestamp = datetime.datetime.now().isoformat()  # 默认当前时间
216                 if os.path.exists(timestamp_path):
217                     try:
218                         with open(timestamp_path, "r", encoding="utf-8") as f:
219                             timestamp = f.read().strip()
220                     except Exception as e:
221                         logger.error(f"读取时间戳失败: {str(e)}")
222                 
223                 # 创建并添加LogEntry对象
224                 entry = LogEntry(issue_id=self.issue_id, round_num=round_num,
225                                  sys_prompt=sys_prompt, prompt=prompt, 
226                                  response=response, timestamp=timestamp, log_path=round_dir,
227                                  modified_files=modified_files)
228                 log_entries.append(entry)
229             except Exception as e:
230                 logger.error(f"读取轮次 {dir_name} 的日志失败: {str(e)}")
231         
232         # 按轮次号排序
233         return sorted(log_entries, key=lambda entry: entry.round_num)
234     
235     def get_issue_round_log_entry(self, round_num: int, include_diff: bool = False) -> Optional[LogEntry]:
236         """
237         获取特定轮次的日志条目
238 
239         Args:
240             round_num: 轮次号
241             include_diff: 是否包含修改信息
242 
243         Returns:
244             Optional[LogEntry]: 指定轮次的日志条目，如果不存在则返回None
245         """
246         round_dir = os.path.join(self.issues_path, f"round_{round_num}")
247         
248         if not os.path.exists(round_dir):
249             logger.warning(f"Issue #{self.issue_id} 的轮次 {round_num} 不存在")
250             return None
251             
252         try:
253             # 直接使用现有方法获取所有轮次，然后过滤出指定轮次
254             all_entries = self.get_issue_log_entries(include_diff)
255             return next((entry for entry in all_entries if entry.round_num == round_num), None)
256         except Exception as e:
257             logger.error(f"获取 Issue #{self.issue_id} 轮次 {round_num} 的日志失败: {str(e)}")
258             return None
259             
260     def rollback_logs(self, target_round: int) -> bool:
261         """
262         将目标轮次之后的日志移至回滚目录
263         
264         Args:
265             target_round: 保留到的轮次，之后的轮次会被移到回滚目录
266             
267         Returns:
268             bool: 操作是否成功
269         """
270         try:
271             # 确保回滚目录存在
272             os.makedirs(self.rollback_path, exist_ok=True)
273             
274             # 获取所有轮次目录
275             round_dirs = [d for d in os.listdir(self.issues_path) 
276                          if os.path.isdir(os.path.join(self.issues_path, d)) 
277                          and d.startswith("round_")]
278             
279             # 筛选出需要回滚的轮次目录
280             rounds_to_rollback = []
281             for dir_name in round_dirs:
282                 try:
283                     round_num = int(dir_name[6:])  # 提取轮次号
284                     if round_num > target_round:
285                         rounds_to_rollback.append((round_num, dir_name))
286                 except ValueError:
287                     continue
288             
289             # 按轮次号排序
290             rounds_to_rollback.sort(key=lambda x: x[0])
291             
292             if not rounds_to_rollback:
293                 logger.info(f"没有轮次需要回滚")
294                 return True
295                 
296             # 移动轮次日志到回滚目录
297             for round_num, dir_name in rounds_to_rollback:
298                 source_path = os.path.join(self.issues_path, dir_name)
299                 dest_path = os.path.join(self.rollback_path, dir_name)
300                 
301                 # 如果目标路径已存在，先删除
302                 if os.path.exists(dest_path):
303                     shutil.rmtree(dest_path)
304                     
305                 # 移动目录
306                 shutil.move(source_path, dest_path)
307                 logger.info(f"已将轮次 {round_num} 的日志移至回滚目录: {dest_path}")
308             
309             # 更新当前轮次
310             self.current_round = self._get_next_round()
311             return True
312             
313         except Exception as e:
314             logger.error(f"回滚日志失败: {str(e)}")
315             return False
316     
317     def get_rollback_log_entries(self, include_diff: bool = False) -> List[LogEntry]:
318         """
319         获取已回滚的所有轮次的日志条目
320 
321         Args:
322             include_diff: 是否包含diff信息
323 
324         Returns:
325             List[LogEntry]: 回滚的日志条目列表，按轮次排序
326         """
327         try:
328             # 如果回滚目录不存在，返回空列表
329             if not os.path.exists(self.rollback_path):
330                 return []
331                 
332             # 临时保存当前issues_path
333             original_path = self.issues_path
334             
335             # 将issues_path指向rollback_path，复用get_issue_log_entries方法
336             self.issues_path = self.rollback_path
337             
338             # 获取回滚目录中的日志条目
339             rollback_entries = self.get_issue_log_entries(include_diff)
340             
341             # 恢复issues_path
342             self.issues_path = original_path
343             
344             return rollback_entries
345         except Exception as e:
346             logger.error(f"获取回滚日志条目失败: {str(e)}")
347             return []
348 
349 if __name__ == "__main__":
350     config = LogConfig("..", 1)
351     log_manager = LogManager(config)
352
```




```
File: core/workflow_engine.py
1 import os
2 import shutil
3 import tempfile
4 import uuid
5 from dataclasses import dataclass
6 from typing import Optional
7 
8 from core.ai import AIConfig
9 from core.chat_processor import ChatProcessor, ChatProcessorConfig
10 from core.code_engineer import CodeEngineer, CodeEngineerConfig
11 from core.comment_formatter import CommentFormatter
12 from core.decision import DecisionProcess
13 from core.diff import Diff
14 from core.file_memory import FileMemory, FileMemoryConfig
15 from core.file_selector import FileSelector
16 from core.git_manager import GitManager, GitConfig
17 from core.log_config import get_logger
18 from core.log_manager import LogManager, LogConfig
19 from core.prompt_generator import PromptGenerator, PromptData
20 from core.version_manager import VersionManager
21 
22 logger = get_logger(__name__)
23 
24 @dataclass
25 class WorkflowEngineConfig:
26     project_dir: str
27     issue_id:int
28     core_model:str = "gpt-4o"
29     data_model:str = "gpt-4o"
30     core_template: float = 0.7
31     data_template: float = 0.7
32     max_retry: int = 3,
33     default_branch: str = "main"
34     mode: str = "client" # ["client", "bot"] bot模式下，每次进行工作时，会hard reset到issues的最新分支上
35     base_url: Optional[str] = None
36     api_key: Optional[str] = None
37     github_remote_url: Optional[str] =None
38     github_token: Optional[str] = None
39 
40 
41 class WorkflowEngine:
42     CODE_TIMES = 0
43     CHAT_TIMES = 0
44     """
45     工作流引擎，协调版本管理、日志管理和AI交互
46     """
47     def __init__(self, config: WorkflowEngineConfig):
48         """
49         初始化工作流引擎
50         
51         Args:
52             config: 工作流配置
53         """
54         self.CODE_TIMES = 0
55         self.CHAT_TIMES = 0
56         # 存储原始配置
57         self.original_config = config
58         
59         # 根据模式设置工作目录
60         if config.mode == "bot":
61             # 创建临时目录作为工作区
62             self.temp_dir = os.path.join(
63                 tempfile.gettempdir(),
64                 f"bella-bot-{config.issue_id}-{str(uuid.uuid4())[:8]}"
65             )
66             os.makedirs(self.temp_dir, exist_ok=True)
67             # 更新配置以使用临时目录
68             self.config = WorkflowEngineConfig(
69                 project_dir=self.temp_dir,
70                 **{k: v for k, v in vars(config).items() if k != 'project_dir'}
71             )
72             logger.info(f"Bot模式：创建临时工作目录 {self.temp_dir}")
73         else:
74             # 客户端模式直接使用指定的目录
75             self.config = config
76             self.temp_dir = None
77             logger.info("当前为client模式")
78 
79         self.project_dir = os.path.abspath(self.config.project_dir)
80         # 创建AI配置
81         self.core_ai_config = AIConfig(
82             model_name=config.core_model,
83             temperature=config.core_template,
84             base_url=config.base_url,
85             api_key=config.api_key
86         )
87         
88         self.data_ai_config = AIConfig(
89             model_name=config.data_model,
90             temperature=config.data_template,
91             base_url=config.base_url,
92             api_key=config.api_key
93         )
94         
95         # 创建Git配置
96         self.git_config = GitConfig(
97             repo_path=self.project_dir,
98             remote_url=config.github_remote_url or os.getenv("GIT_REMOTE"),
99             auth_token=config.github_token or os.getenv("GITHUB_TOKEN"),
100             default_branch=config.default_branch
101         )
102         
103         # 创建日志配置
104         self.log_config = LogConfig(
105             project_dir=self.project_dir,
106             issue_id=config.issue_id,
107             mode=config.mode
108         )
109         
110         # 初始化管理器
111         self.git_manager = GitManager(config=self.git_config)
112 
113         # 检出对应的分支
114         if self.config.mode == "bot":
115             try:
116                 # 重置到issue对应的分支
117                 self.git_manager.reset_to_issue_branch(self.config.issue_id)
118                 logger.info(f"成功初始化Bot模式环境，工作目录: {self.temp_dir}")
119             except Exception as e:
120                 logger.error(f"初始化Bot模式环境失败: {str(e)}")
121                 self._cleanup_environment()
122                 raise
123 
124         self.log_manager = LogManager(config=self.log_config)
125         
126         # 初始化文件记忆管理，传入log_manager
127         self.file_memory = FileMemory(
128             config=FileMemoryConfig(
129                 git_manager=self.git_manager,
130                 ai_config=self.data_ai_config,
131                 project_dir=self.project_dir,
132                 log_manager=self.log_manager
133             )
134         )
135         self.version_manager = VersionManager(
136             issue_id=config.issue_id,
137             ai_config=self.core_ai_config,
138             log_manager=self.log_manager,
139             git_manager=self.git_manager,
140             file_memory=self.file_memory
141         )
142         self.file_selector = FileSelector(
143             self.project_dir,
144             self.config.issue_id,
145             ai_config=self.core_ai_config
146         )
147 
148         # 初始化代码工程师
149         self.code_engineer_config = CodeEngineerConfig(
150             project_dir=self.project_dir,
151             ai_config=self.core_ai_config
152         )
153         self.engineer = CodeEngineer(
154             self.code_engineer_config,
155             self.log_manager,
156             Diff(self.data_ai_config)
157         )
158         
159         # 初始化聊天处理器
160         self.chat_processor = ChatProcessor(
161             ai_config=self.core_ai_config,
162             log_manager=self.log_manager,
163             config=ChatProcessorConfig(system_prompt="你是一个项目助手，负责回答关于代码库的问题。下面会给出用户的问题以及相关的项目文件信息。")
164         )
165         
166         # 初始化决策环境
167         self.decision_env = DecisionProcess(
168             ai_config=self.core_ai_config,
169             version_manager=self.version_manager
170         )
171 
172     def _prepare_memory(self):
173         current_round = self.log_manager.get_current_round()
174 
175         # 如果轮次大于1，增量更新上一轮修改的文件详细信息
176         if self.file_memory and current_round > 1:
177             self.file_memory.update_file_details()
178             logger.info("已更新文件详细信息")
179     
180     def process_requirement(self, user_requirement: str) -> Optional[str]:
181         """
182         处理用户需求
183         
184         Args:
185             user_requirement: 用户需求
186 
187         Returns:
188             str: 处理结果的响应文本
189         """
190         try:
191 
192             response = self._process_requirement_internal(user_requirement)
193             
194             # 如果是bot模式，在结束时清理临时目录
195             if self.config.mode == "bot":
196                 self._cleanup_environment()
197             
198             return response
199         except Exception as e:
200             logger.error(f"处理需求时发生错误: {str(e)}")
201             raise
202 
203 
204     def _finalize_changes(self, mode: str, comment_text: str) -> bool:
205         """
206         完成更改，在bot模式下提交并推送更改
207 
208         Args:
209             mode: 工作模式 ("client" 或 "bot")
210             comment_text: comment内容
211 
212         Returns:
213             bool: 操作是否成功
214         """
215         if mode == "bot":
216             self.git_manager.commit(f"Issues #{self.config.issue_id} - Changes by Bella-Issues-Bot")
217             self.git_manager.push()
218             self.git_manager.add_issue_comment(self.config.issue_id, comment_text)
219         return True
220         
221     def _cleanup_environment(self) -> None:
222         """
223         清理工作环境，删除临时目录
224         """
225         if self.config.mode == "bot" and self.temp_dir and os.path.exists(self.temp_dir):
226             try:
227                 # 关闭git仓库连接
228                 if hasattr(self, 'git_manager') and self.git_manager:
229                     self.git_manager.delete_local_repository()
230                 
231                 # 删除临时目录
232                 shutil.rmtree(self.temp_dir, ignore_errors=True)
233                 logger.info(f"已清理临时工作目录: {self.temp_dir}")
234             except Exception as e:
235                 logger.warning(f"清理临时目录时出错: {str(e)}")
236                 # 即使清理失败也不抛出异常，让主流程继续
237 
238     def _process_requirement_internal(self, user_requirement: str) -> Optional[str]:
239         """
240         内部处理需求的方法
241         
242         Args:
243             user_requirement: 用户需求
244             
245         Returns:
246             str: 处理结果
247         """
248         # 先通过决策环境分析需求类型
249         decision_result = self.decision_env.analyze_requirement(user_requirement)
250         
251         logger.info(f"决策结果: 是否需要修改代码={decision_result.needs_code_modification}, "
252                     f"理由={decision_result.reasoning}")
253         
254         if decision_result.needs_code_modification:
255             # 执行代码修改流程
256             response = self._run_code_generation_workflow(user_requirement)
257         else: 
258             # 执行对话流程
259             response = self._run_chat_workflow(user_requirement)
260         
261         # 如果是Bot模式且有GitHub配置，自动回复到issue
262         if self.config.mode == "bot":
263             try:
264                 current_text = CommentFormatter.format_diff_blocks(comment_text=response, branch_name=self.git_manager.get_current_branch())
265                 self._finalize_changes(mode=self.config.mode, comment_text=current_text)
266                 logger.info(f"更改已经推送到远端，并添加了Issue评论")
267             except Exception as e:
268                 logger.error(f"添加Issue评论时出错: {str(e)}")
269                 
270         return response
271     
272     def _run_code_generation_workflow(self, user_requirement: str) -> Optional[str]:
273         """
274         执行代码生成流程，基于example_code_generate.py的逻辑
275         
276         Args:
277             user_requirement: 用户需求
278             
279         Returns:
280             str: 处理结果
281         """
282         logger.info("开始执行代码生成流程")
283 
284         # 确定当前版本
285         requirement, history = self.version_manager.ensure_version_and_generate_context(user_requirement)
286 
287         self._prepare_memory()
288 
289         # 生成提示词
290         user_prompt = self._get_user_prompt(requirement, history)
291 
292         # 根据提示词修改代码
293         success, response = self.engineer.process_prompt(prompt=user_prompt)
294 
295         # 提交更改
296         if success:
297             return response
298         else:
299             self.CODE_TIMES += 1
300             if self.CODE_TIMES >= self.config.max_retry:
301                 logger.error("code workflow超过最大重试次数")
302                 return self._run_chat_workflow(user_requirement)
303             else:
304                 return self._run_code_generation_workflow(user_requirement)
305     
306     def _run_chat_workflow(self, user_requirement: str) -> Optional[str]:
307         """
308         执行聊天流程，基于example_chat_process.py的逻辑
309         
310         Args:
311             user_requirement: 用户需求
312             
313         Returns:
314             str: 处理结果
315         """
316         logger.info("开始执行聊天回复流程")
317 
318         self._prepare_memory()
319 
320         history = self.version_manager.get_formatted_history()
321 
322         # 生成提示词
323         user_prompt = self._get_user_prompt(user_requirement, history)
324         
325         # 处理聊天请求
326         response = self.chat_processor.process_chat(user_prompt)
327 
328         if(response):
329             return response
330         else:
331             self.CHAT_TIMES += 1
332             if self.CHAT_TIMES >= self.config.max_retry:
333                 logger.error("chat workflow超过最大重试次数")
334                 return None
335             else:
336                 return self._run_chat_workflow(user_requirement)
337 
338     def _get_user_prompt(self, requirement: str, history: str) -> str:
339         # 选择文件
340         files = self.file_selector.select_files_for_requirement(requirement)
341         descriptions = FileMemory.get_selected_file_descriptions(self.project_dir, files)
342 
343         # 准备提示词数据
344         data = PromptData(
345             requirement=requirement,
346             project_dir=self.project_dir,
347             steps=history,
348             files=files,
349             file_desc=descriptions
350         )
351 
352         # 生成提示词
353         return PromptGenerator.generatePrompt(data)
354
```




```
File: examples/example_workflow.py
1 """
2 这个示例展示如何使用WorkflowEngine处理用户需求，自动决策是代码生成还是对话流程
3 """
4 import logging
5 import os
6 
7 from dotenv import load_dotenv
8 
9 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
10 from core.log_config import setup_logging
11 
12 
13 def main():
14     setup_logging(log_level=logging.DEBUG)
15     # 加载环境变量
16     load_dotenv()
17     
18     # 创建工作目录
19     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
20     issue_id = 5
21     
22     # 创建工作流引擎配置
23     config = WorkflowEngineConfig(
24         project_dir=project_dir,
25         issue_id=issue_id,
26         core_model="coder-model",
27         data_model="gpt-4o",
28         core_template=1,
29         data_template=0.7,
30         default_branch="dev"
31     )
32     
33     # 初始化工作流引擎
34     workflow_engine = WorkflowEngine(config)
35 
36     requirement = """
37     分析项目的所有代码。把项目的Read.me进行完善。尤其是未完成的。
38     """
39     
40     # 处理代码修改需求
41     workflow_engine.process_requirement(requirement)
42 
43 if __name__ == "__main__":
44     main()
45
```




```
File: examples/example_code_generate.py
1 import logging
2 import os
3 
4 from dotenv import load_dotenv
5 
6 from core.ai import AIConfig
7 from core.code_engineer import CodeEngineerConfig, CodeEngineer
8 from core.diff import Diff
9 from core.file_memory import FileMemory, FileMemoryConfig
10 from core.file_selector import FileSelector
11 from core.git_manager import GitManager, GitConfig
12 from core.log_config import setup_logging
13 from core.log_manager import LogManager, LogConfig
14 from core.prompt_generator import PromptGenerator, PromptData
15 from core.version_manager import VersionManager
16 
17 
18 def main():
19     setup_logging(log_level=logging.DEBUG)
20     # 加载环境变量
21     load_dotenv()
22     
23     # 创建工作目录
24     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
25 
26     issue_id = 3
27     
28     # 初始化日志管理器
29     log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)
30     log_manager = LogManager(config=log_config)
31     current_round = log_manager.get_current_round()
32 
33     
34     # 初始化Git管理器
35     git_config = GitConfig(
36         repo_path=project_dir
37     )
38     git_manager = GitManager(config=git_config)
39     
40     # 初始化AI助手
41     ai_config = AIConfig(
42         model_name="coder-model",
43         temperature=1
44     )
45     
46     # 初始化版本管理器
47     version_manager = VersionManager(issue_id=issue_id, log_manager=log_manager, git_manager=git_manager, ai_config=ai_config)
48 
49     current_requirement = '''
50     将 example_chat_process.py 和 example_code_generate.py的流程整合到 workflow_engine.py 中，目前两个代码文件都是写代码和回复用户的完整流程。
51     使用DecisionEnvironment来决策选择何种模式。
52     '''
53     requirement, history = version_manager.ensure_version_and_generate_context(current_requirement)
54 
55     if current_round > 1:
56         file_memory = FileMemory(config=FileMemoryConfig(git_manager=git_manager, ai_config=ai_config, project_dir=project_dir))
57         file_memory.update_file_details()
58 
59     selector = FileSelector(
60         project_dir,
61         issue_id,
62         ai_config=ai_config,
63     )
64 
65     files = selector.select_files_for_requirement(requirement)
66 
67     descriptions = FileMemory.get_selected_file_descriptions(project_dir, files)
68 
69     data = PromptData(requirement=requirement, project_dir=project_dir, steps = history, files=files, file_desc=descriptions)
70     user_prompt = PromptGenerator.generatePrompt(data)
71     config = CodeEngineerConfig(project_dir=project_dir, ai_config=ai_config)
72 
73     engineer = CodeEngineer(config, LogManager(LogConfig(project_dir=project_dir, issue_id=issue_id)), Diff(AIConfig(temperature=0.1,
74                                                                                                               model_name="gpt-4o")))
75     engineer.process_prompt(prompt=user_prompt)
76 
77 
78 if __name__ == "__main__":
79     main()
80
```




```
File: examples/example_terminal.py
1 """
2 Example showing how to run the workflow from both terminal and programmatically.
3 
4 To run from terminal:
5 python -m client.terminal --issue-id 42 --requirement "Create a README file"
6 
7 Or programmatically as shown below:
8 """
9 import logging
10 
11 from client.runner import run_workflow
12 from core.log_config import setup_logging
13 
14 
15 def example_run():
16     """Example of running the workflow programmatically."""
17     requirement = """
18     Create a simple README file with project description and setup instructions.
19     """
20     
21     run_workflow(issue_id=42, requirement=requirement)
22 
23 
24 if __name__ == "__main__":
25     setup_logging(log_level=logging.DEBUG)
26     example_run()
27
```




```
File: examples/advanced/custom_workflow.py
1 """
2 高级示例：自定义工作流处理程序
3 
4 展示如何将bella-issues-bot集成到自定义应用程序中，
5 包括自定义前处理和后处理逻辑。
6 """
7 
8 import os
9 from typing import Optional
10 from client.runner import run_workflow
11 
12 
13 def preprocess_requirement(raw_requirement: str) -> str:
14     """
15     预处理用户需求，增加额外的上下文信息
16     
17     Args:
18         raw_requirement: 原始需求文本
19         
20     Returns:
21         增强后的需求文本
22     """
23     # 例如：添加项目特定的规范或约束
24     return f"{raw_requirement}\n\n注意：请确保代码遵循PEP 8规范，并包含适当的单元测试。"
25 
26 
27 def postprocess_response(response: str) -> str:
28     """
29     处理AI响应，进行后期格式化或额外操作
30     
31     Args:
32         response: AI生成的原始响应
33         
34     Returns:
35         处理后的响应
36     """
37     # 例如：添加时间戳或标记
38     from datetime import datetime
39     timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
40     return f"处理时间: {timestamp}\n\n{response}"
41 
42 
43 # 示例使用
44 if __name__ == "__main__":
45     # 1. 读取并预处理需求
46     with open("requirements/feature_request.txt", "r") as f:
47         raw_requirement = f.read()
48     
49     enhanced_requirement = preprocess_requirement(raw_requirement)
50     
51     # 2. 运行工作流
52     response = run_workflow(
53         issue_id=301,
54         requirement=enhanced_requirement,
55         project_dir=os.getenv("PROJECT_DIR", "."),
56         core_model=os.getenv("CORE_MODEL", "gpt-4o"),
57         core_temperature=float(os.getenv("CORE_TEMP", "0.7"))
58     )
59     
60     # 3. 后处理响应
61     final_response = postprocess_response(response)
62     
63     print(final_response)
64
```




```
File: client/runner.py
1 """
2 Programmatic API for running the WorkflowEngine.
3 Provides a simplified interface for use in Python scripts.
4 """
5 
6 import os
7 from typing import Optional, Dict, Any, Union
8 
9 from dotenv import load_dotenv
10 
11 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
12 
13 
14 def run_workflow(
15     issue_id: int,
16     requirement: str,
17     project_dir: Optional[str] = None,
18     model: Optional[str] = None,  # 统一的模型设置
19     core_model: Optional[str] = "gpt-4o",
20     data_model: Optional[str] = None,  # 默认与core_model相同
21     temperature: Optional[float] = None,  # 统一的温度设置
22     core_temperature: float = 0.7,
23     data_temperature: float = 0.7,
24     max_retry: int = 3,
25     default_branch: str = "main",
26     mode: str = "client",
27     base_url: Optional[str] = None,
28     api_key: Optional[str] = None,
29     github_remote_url: Optional[str] = None,
30     github_token: Optional[str] = None,
31     **kwargs: Dict[str, Any]
32 ) -> None:
33     """Run the WorkflowEngine with the given configuration."""
34     # Load environment variables
35     load_dotenv()
36     
37     # Use current directory if no project_dir specified
38     if project_dir is None:
39         project_dir = os.getcwd()
40     
41     # 处理统一的模型配置
42     if model is not None:
43         core_model = model
44         data_model = model
45     
46     # 如果未指定data_model，则默认与core_model相同
47     if data_model is None:
48         data_model = core_model
49     
50     # 处理统一的温度配置
51     if temperature is not None:
52         core_temperature = temperature
53         data_temperature = temperature
54     
55     # Create config with provided parameters
56     config = WorkflowEngineConfig(
57         project_dir=project_dir, issue_id=issue_id, 
58         core_model=core_model, data_model=data_model,
59         core_template=core_temperature, data_template=data_temperature,
60         max_retry=max_retry, default_branch=default_branch, mode=mode, 
61         base_url=base_url, api_key=api_key, github_remote_url=github_remote_url,
62         github_token=github_token
63     )
64     
65     # Run the workflow engine
66     engine = WorkflowEngine(config)
67     response = engine.process_requirement(requirement)
68     
69     return response
70
```




```
File: client/cli.py
1 """
2 Command-line interface for the WorkflowEngine.
3 Provides functionality to parse command-line arguments and run the engine.
4 """
5 
6 import argparse
7 import os
8 import sys
9 from typing import Optional, Dict, Any
10 
11 
12 def parse_args() -> argparse.Namespace:
13     """Parse command-line arguments for the WorkflowEngine."""
14     parser = argparse.ArgumentParser(
15         description="Run the WorkflowEngine to process user requirements"
16     )
17 
18     # Required arguments
19     parser.add_argument(
20         "--project-dir", 
21         "-p",
22         type=str, 
23         default=os.path.abspath(os.getcwd()),
24         help="Path to the project directory (default: current directory)"
25     )
26     parser.add_argument(
27         "--issue-id", 
28         "-i",
29         type=int, 
30         required=True,
31         help="The ID of the issue being processed"
32     )
33     parser.add_argument(
34         "--requirement", 
35         "-r",
36         type=str, 
37         help="The user requirement text"
38     )
39     parser.add_argument(
40         "--requirement-file", 
41         "-f",
42         type=str, 
43         help="Path to file containing the user requirement"
44     )
45 
46     # Optional arguments for WorkflowEngineConfig
47     # 统一模型配置
48     parser.add_argument(
49         "--model", 
50         "-m",
51         type=str, 
52         help="Model to use for both core and data operations (优先级高于单独配置)"
53     )
54     parser.add_argument(
55         "--temperature",
56         "-t",
57         type=float, 
58         help="Temperature for both core and data models (优先级高于单独配置)"
59     )
60     
61     # 独立模型配置
62     parser.add_argument(
63         "--core-model", 
64         "--cm",
65         type=str, 
66         default="gpt-4o",
67         help="Model to use for core AI operations (当未设置--model时使用)"
68     )
69     parser.add_argument(
70         "--data-model", 
71         "--dm",
72         type=str, 
73         default="gpt-4o",
74         help="Model to use for data operations (当未设置--model时使用)"
75     )
76     parser.add_argument(
77         "--core-temperature",
78         "--ct",
79         type=float, 
80         default=0.7,
81         help="Temperature for core model (当未设置--temperature时使用)"
82     )
83     parser.add_argument(
84         "--data-temperature",
85         "--dt",
86         type=float, 
87         default=0.7,
88         help="Temperature for data model (当未设置--temperature时使用)"
89     )
90     parser.add_argument(
91         "--max-retry", 
92         "--retry",
93         type=int, 
94         default=3,
95         help="Maximum number of retry attempts"
96     )
97     parser.add_argument(
98         "--default-branch", 
99         "--branch",
100         type=str, 
101         default="main",
102         help="Default branch name"
103     )
104     parser.add_argument(
105         "--mode",
106         "-md",
107         type=str,
108         choices=["client", "bot"],
109         default="client",
110         help="Operation mode: 'client' or 'bot'"
111     )
112     parser.add_argument(
113         "--base-url",
114         "-u",
115         type=str,
116         help="Base URL for API calls"
117     )
118     parser.add_argument(
119         "--api-key",
120         "-k",
121         type=str,
122         help="API key for authentication"
123     )
124     parser.add_argument(
125         "--github-remote-url",
126         "--git-url",
127         type=str,
128         help="GitHub remote repository URL"
129     )
130     parser.add_argument(
131         "--github-token",
132         "--git-token",
133         type=str,
134         help="GitHub authentication token"
135     )
136     parser.add_argument(
137         "--base-branch",
138         "-b",
139         type=str,
140         default="main",
141         help="Base branch for pull requests (default: main)"
142     )
143 
144     parser.add_argument(
145         "-l",
146         "--log-level",
147         choices=["DEBUG", "INFO", "WARNING", "ERROR"],
148         default="INFO",
149         help="Logging level")
150     
151     return parser.parse_args()
152 
153 
154 def get_requirement_text(args: argparse.Namespace) -> Optional[str]:
155     """Get requirement text from arguments or file."""
156     if args.requirement:
157         return args.requirement
158     elif args.requirement_file:
159         try:
160             with open(args.requirement_file, 'r', encoding='utf-8') as file:
161                 return file.read()
162         except IOError as e:
163             print(f"Error reading requirement file: {e}", file=sys.stderr)
164             return None
165     else:
166         print("No requirement specified. Use --requirement or --requirement-file", file=sys.stderr)
167         return None
168 
169 
170 def build_config_from_args(args: argparse.Namespace) -> Dict[str, Any]:
171     """Build WorkflowEngineConfig parameters from command line arguments."""
172     
173     # 处理统一的模型和温度配置
174     core_model = args.core_model
175     data_model = args.data_model
176     core_temperature = args.core_temperature
177     data_temperature = args.data_temperature
178     
179     # 如果设置了统一模型，则覆盖个别设置
180     if args.model:
181         core_model = args.model
182         data_model = args.model
183         
184     # 如果设置了统一温度，则覆盖个别设置
185     if args.temperature is not None:
186         core_temperature = args.temperature
187         data_temperature = args.temperature
188     
189     config_params = {
190         "project_dir": args.project_dir,
191         "issue_id": args.issue_id,
192         "core_model": core_model,
193         "data_model": data_model,
194         "core_template": core_temperature,  # Note: using template to match original param name
195         "data_template": data_temperature,  # Note: using template to match original param name
196         "max_retry": args.max_retry, 
197         "default_branch": args.base_branch,
198         "mode": args.mode
199     }
200     
201     # Add optional parameters if they're specified
202     if args.base_url:
203         config_params["base_url"] = args.base_url
204     if args.api_key:
205         config_params["api_key"] = args.api_key
206     if args.github_remote_url:
207         config_params["github_remote_url"] = args.github_remote_url
208     if args.github_token:
209         config_params["github_token"] = args.github_token
210         
211     return config_params
212
```




```
File: README.md
1 # bella-issues-bot
2 
3 - [![Static Badge](https://img.shields.io/badge/deep-wiki-blue?style=flat-square)](https://deepwiki.com/bella-top/bella-issues-bot)
4 - [![Static Badge](https://img.shields.io/badge/Bella-support-%23C76300?style=flat-square)](https://doc.bella.top/)
5 
6 中文 | [English](./README.en.md)
7 
8 ## 项目简介
9 
10 bella-issues-bot 是一个基于人工智能的多功能代码开发助手，具备两种强大的工作模式：
11 
12 1. **个人开发助手模式**：在日常开发过程中，作为命令行工具辅助编码，帮助分析代码、生成实现、解决技术难题。
13 2. **GitHub自动化模式**：集成到GitHub工作流中，自动监控和处理项目Issues，无需人工干预即可分析需求、提出解决方案并实现代码变更。
14 
15 通过对项目结构的深入理解和强大的代码生成能力，bella-issues-bot 能够显著提高开发效率，减少重复工作，让您专注于更有创造性的任务。
16 
17 ## 主要功能
18 
19 - **需求分析**：自动理解和分解用户的功能需求，确定所需的代码修改
20 - **代码生成**：根据需求生成符合项目风格的代码，自动实现新功能或修复问题
21 - **版本管理**：与Git深度集成，支持分支创建、代码提交和拉取请求的自动管理
22 - **记忆系统**：记录项目文件描述和操作历史，提供上下文感知能力，持续改进代码质量
23 
24 ### 典型使用场景
25 
26 - **日常开发辅助**：在本地开发过程中，使用命令行工具快速生成代码、解决技术问题
27 - **项目自动化**：集成到GitHub工作流，实现Issue的自动处理和代码实现
28 - **代码文档生成**：自动分析项目文件并生成详细的功能描述
29 - **技术难题解决**：分析项目上下文后，针对性地提供解决方案
30 
31 ## 记忆与上下文管理
32 
33 bella-issues-bot 配备了强大的记忆系统，由三个核心组件构成：
34 
35 ### 记忆系统的工作流程
36 
37 1. **初始化阶段**：首次运行时，系统会扫描整个项目并为每个文件生成详细描述
38 2. **增量更新**：后续运行时，只会更新新增或修改的文件描述，提高效率
39 3. **上下文提取**：处理用户需求时，系统根据需求内容选择相关文件作为上下文
40 
41 ### 1. 日志管理 (LogManager)
42 
43 LogManager 负责记录每次交互的完整历史，包括：
44 - 系统提示词和用户需求
45 - AI响应内容
46 - 文件修改记录和差异对比
47 
48 这些日志按issue和轮次组织，支持历史追溯和问题诊断。每轮交互都会生成详细日志，便于追踪AI的决策过程和代码修改历史。
49 
50 ### 2. 版本管理 (VersionManager)
51 
52 VersionManager 提供智能的版本控制功能：
53 - 自动提取历史轮次的需求和响应
54 - 生成格式化的历史执行记录作为上下文
55 - 分析当前需求与历史需求的关系
56 - 根据需要执行版本回退操作
57 
58 系统会分析新需求与先前修改的关系，判断是否需要回滚，确保代码修改的连贯性和一致性。
59 
60 ### 3. 文件记忆 (FileMemory)
61 
62 FileMemory 模块为项目的每个文件维护详细描述：
63 - 自动生成文件功能、结构和关系描述
64 - 跟踪文件变更，更新受影响文件的描述
65 - 提供上下文相关的文件选择
66 - 支持配置忽略文件，默认包含项目的.gitignore，支持自定义添加.eng/.engignore
67 
68 这使得AI助手能够理解整个代码库的结构和功能，在修改代码时考虑到更广泛的项目上下文。
69 
70 ## 安装方法
71 
72 ### 通过 pip 安装
73 
74 ```bash
75 pip install bella-issues-bot
76 ```
77 
78 ### 从源码安装
79 
80 ```bash
81 git clone https://github.com/szl97/bella-issues-bot.git
82 cd bella-issues-bot
83 pip install -e .
84 ```
85 
86 ## 系统要求
87 
88 - Python 3.10 或更高版本（<3.13）
89 - Git 客户端（用于版本控制功能）
90 - OpenAI API 密钥（用于 AI 功能）
91 
92 ## 配置文件
93 
94 bella-issues-bot 支持多种配置方式：
95 
96 ### 环境变量配置
97 
98 工具会读取以下环境变量：
99 
100 - `OPENAI_API_KEY`: OpenAI API密钥（必需）
101 - `OPENAI_API_BASE`: OpenAI API基础URL（可选，用于自定义API端点）
102 - `GITHUB_REMOTE_URL`: GitHub远程仓库URL（可选，用于GitHub集成）
103 - `GITHUB_TOKEN`: GitHub身份验证令牌（可选，用于GitHub集成）
104 
105 ### 项目配置文件
106 
107 
108 - `.eng/system.txt`: 配置代码工程师的提示词
109 - `.eng/.engignore`: 类似于 `.gitignore`，用于指定文件记忆系统应忽略的文件
110 
111 示例 `.engignore` 文件:
112 ```
113 # 忽略所有日志文件
114 *.log
115 
116 # 忽略构建目录
117 /build/
118 /dist/
119 
120 # 忽略虚拟环境
121 /venv/
122 /.venv/
123 
124 # 忽略缓存文件
125 __pycache__/
126 *.py[cod]
127 *$py.class
128 ```
129 
130 ## 详细使用示例
131 
132 ### 0. 进入您的项目目录
133 
134 ### 1. 初始化文件记忆系统
135 
136 首次使用前，建议初始化文件记忆系统，这将帮助 AI 理解您的项目结构：
137 
138 ```bash
139 # 在项目根目录执行
140 bella-file-memory --project-dir .
141 ```
142 
143 这将分析您的项目文件并生成描述信息，存储在 `.eng/memory/file_details.txt` 中。
144 
145 ### 2. 作为个人开发助手使用
146 
147 ```bash
148 # 基本使用
149 bella-issues-bot --issue-id 123 --requirement "实现一个新的日志记录功能"
150 
151 # 使用自定义模型和温度
152 bella-issues-bot --issue-id 123 --requirement "优化文件读取性能" --core-model gpt-4o --core-temperature 0.5
153 ```
154 
155 ### 3. 设置 GitHub 工作流
156 
157 为您的项目生成 GitHub Actions 工作流配置：
158 
159 ```bash
160 # 生成默认工作流配置
161 bella-github-workflows
162 
163 # 自定义基础分支和模型
164 bella-github-workflows --base-branch develop --model gpt-4o
165 ```
166 
167 生成的工作流文件将保存在 `.github/workflows/` 目录中。
168 
169 ### 4. 使用编程 API
170 
171 ```python
172 from client.runner import run_workflow
173 
174 # 基本使用
175 run_workflow(
176     issue_id=123,
177     requirement="添加单元测试覆盖核心功能",
178     project_dir="./my_project"
179 )
180 
181 # 高级配置
182 run_workflow(
183     issue_id=123,
184     requirement="重构数据处理模块以提高性能",
185     project_dir="./my_project",
186     core_model="gpt-4o",
187     data_model="gpt-4o",
188     core_temperature=0.7,
189     data_temperature=0.5,
190     mode="client",  # 或 "bot" 用于 GitHub 自动化
191     max_retry=5
192 )
193 ```
194 
195 ## 项目结构
196 
197 ```
198 bella-issues-bot/
199 ├── core/               # 核心功能模块
200 │   ├── ai.py           # AI 助手接口
201 │   ├── file_memory.py  # 文件记忆系统
202 │   ├── git_manager.py  # Git 版本控制
203 │   └── workflow_engine.py  # 工作流引擎
204 ├── client/             # 客户端接口
205 │   ├── terminal.py     # 命令行界面
206 │   ├── file_memory_client.py  # 文件记忆客户端
207 │   └── github_workflow_generator.py  # GitHub 工作流生成器
208 └── examples/           # 使用示例
209 ```
210
```




```
File: client/README.md
1 # WorkflowEngine 客户端
2 
3 一个强大的命令行接口和编程API，用于运行WorkflowEngine处理用户需求，支持个人开发助手模式和GitHub自动化工作流模式。
4 
5 ## 记忆与上下文管理
6 
7 客户端依赖于强大的后台记忆系统，包括三个核心组件：
8 
9 ### 日志管理 (LogManager)
10 
11 LogManager负责存储每次交互的详细记录：
12 
13 - **结构化存储**：日志按issue ID和轮次有序组织，便于检索
14 - **完整性**：记录系统提示词、用户提示词、AI响应和文件修改
15 - **差异追踪**：保存每个修改文件的完整差异信息
16 
17 所有日志保存在项目的`.eng/memory`目录下，按照`issues/#<issue-id>/round_<num>`格式组织，可随时查看历史交互。
18 
19 ### 版本管理 (VersionManager)
20 
21 VersionManager提供智能版本控制功能：
22 
23 - **历史分析**：自动提取历史轮次的数据形成上下文
24 - **需求整合**：在新需求与历史需求有冲突时，提供智能整合
25 - **版本回退**：根据需要自动执行版本回退操作
26 
27 每次启动新的需求处理时，系统会：
28 1. 提取过去所有轮次的需求和响应
29 2. 格式化为结构化历史记录
30 3. 分析新需求与历史的关系
31 4. 决定是保持当前状态还是执行回退
32 
33 ### 文件记忆 (FileMemory)
34 
35 FileMemory为AI提供项目文件的深度理解：
36 
37 - **自动描述**：为项目中的每个文件生成功能描述
38 - **增量更新**：只更新被修改的文件描述，提高效率
39 - **批量处理**：使用智能分批策略处理大型代码库
40 - **失败处理**：对无法处理的文件提供重试机制
41 
42 当工作流运行时，系统会：
43 1. 检测新建或修改的文件
44 2. 使用AI生成这些文件的功能描述
45 3. 将描述保存在`.eng/memory/file_details.txt`中
46 4. 在后续需求处理时提供这些描述作为上下文
47 
48 ## 工作模式
49 
50 bella-issues-bot 支持两种主要工作模式：
51 
52 - **客户端模式 (client)**：默认模式，适合作为个人开发助手使用，每次运行时基于project_dir目录下的当前代码状态进行操作。
53 - **机器人模式 (bot)**：专为GitHub集成设计，会在project_dir目录下创建临时目录作为工作区，自动拉取issues对应的最新分支状态，处理完成后自动提交更改并在Issues中回复处理结果，最后清理临时工作区。
54 
55 ## 安装方法
56 
57 ### 通过 pip 安装
58 
59 ```bash
60 pip install bella-issues-bot
61 ```
62 
63 ### 从源码安装
64 
65 ```bash
66 git clone https://github.com/szl97/bella-issues-bot.git
67 cd bella-issues-bot
68 pip install -e .
69 ```
70 
71 ## 系统要求
72 
73 - Python 3.10 或更高版本 (< 3.13)
74 - Git 客户端
75 - OpenAI API 密钥
76 
77 ## 命令行使用方式（个人开发助手模式）
78 
79 你可以通过以下两种方式从命令行运行WorkflowEngine：
80 
81 ### 使用安装后的CLI命令
82 
83 ```bash
84 bella-issues-bot --issue-id 42 --requirement "创建一个README文件"
85 ```
86 
87 ### 直接使用Python模块
88 
89 ```bash
90 python -m client.terminal --issue-id 42 --requirement "创建一个README文件"
91 ```
92 
93 ### 命令行参数
94 
95 #### 基础参数
96 
97 - `--issue-id -i`：（必需）问题ID，用于跟踪和引用
98 - `--requirement -r` 或 `--requirement-file -f`：（必需）具体需求描述或包含需求的文件路径
99 - `--project-dir -p`：项目目录路径（默认：当前目录）
100 
101 #### AI模型配置
102 
103 - `--model -m`： 同时配置核心模型和数据模型
104 - `--temperature -t`： 同时配置核心模型和数据模型温度
105 - `--core-model --cm`：核心AI操作使用的模型（默认：gpt-4o）
106 - `--data-model --dm`：数据操作使用的模型（默认：gpt-4o）
107 - `--core-temperature --ct`：核心模型的温度参数（默认：0.7）
108 - `--data-temperature --dt`：数据模型的温度参数（默认：0.7）
109 
110 #### 工作流配置
111 
112 - `--mode`：工作模式，可选"client"或"bot"（默认：client）
113   - `client`：个人开发助手模式，基于当前代码状态工作
114   - `bot`：GitHub自动化模式，拉取最新分支，自动提交并回复Issues
115 - `--default-branch --branch`：默认Git分支（默认：main）
116 - `--base-url -u`：API调用的基础URL
117 - `--api-key -k`：API密钥（也可以通过OPENAI_API_KEY环境变量设置）
118 - `--github-remote-url --git-url`：GitHub远程URL
119 - `--github-token --git-token`：GitHub令牌
120 
121 #### 执行控制
122 
123 - `--max-retry`：最大重试次数（默认：3）
124 
125 ### 示例命令
126 
127 ```bash
128 # 基本用法
129 bella-issues-bot --issue-id 123 --requirement "添加用户认证功能"
130 
131 # 从文件读取需求
132 bella-issues-bot --issue-id 123 --requirement-file requirements.txt
133 
134 # 自定义模型和温度
135 bella-issues-bot --issue-id 123 --requirement "优化数据库查询" --core-model gpt-4o --core-temperature 0.5
136 
137 # GitHub机器人模式
138 bella-issues-bot --issue-id 123 --requirement "修复登录bug" --mode bot --github-token YOUR_TOKEN
139 ```
140 
141 ### 简易脚本使用
142 
143 你也可以使用提供的脚本简化命令行调用：
144 
145 ```bash
146 ./scripts/run_bot.sh <问题ID> [需求文件路径]
147 ```
148 
149 ## 编程方式使用
150 
151 你也可以在Python代码中以编程方式使用客户端包：
152 
153 ```python
154 from client.runner import run_workflow
155 
156 # 基本用法
157 result = run_workflow(
158     issue_id=42,
159     requirement="为项目创建一个README文件",
160     project_dir="./my_project"
161 )
162 print(f"处理结果: {result}")
163 
164 # 高级配置
165 result = run_workflow(
166     issue_id=123,
167     requirement="实现用户注册功能",
168     project_dir="./my_project",
169     core_model="gpt-4o",
170     data_model="gpt-4o",
171     core_temperature=0.7,
172     data_temperature=0.5,
173     mode="client",
174     max_retry=5,
175     default_branch="develop",
176     github_remote_url="https://github.com/username/repo.git",
177     github_token="your_github_token"
178 )
179 ```
180 
181 ## 环境变量
182 
183 工具会读取以下环境变量：
184 
185 - `OPENAI_API_KEY`：OpenAI的API密钥（必需）
186 - `OPENAI_API_BASE`：OpenAI API的基础URL（可选）
187 - `GITHUB_REMOTE_URL`：GitHub远程仓库URL（可选，用于bot模式）
188 - `GITHUB_TOKEN`：GitHub身份验证令牌（可选，用于bot模式）
189 
190 ## 配置文件
191 
192 除了命令行参数和环境变量外，bella-issues-bot 还支持以下配置文件：
193 
194 - `.eng/config.json`：项目级配置文件，可以设置默认参数
195 - `.eng/.engignore`：指定文件记忆系统应忽略的文件模式
196 
197 ## 工作流程详解
198 
199 ### 个人开发助手模式 (client)
200 
201 1. **初始化**：创建工作流引擎，设置项目目录和AI配置
202 2. **文件记忆**：检查并更新文件记忆系统
203 3. **版本管理**：分析历史需求和当前需求的关系
204 4. **需求处理**：使用AI分析需求并生成代码修改
205 5. **代码实现**：应用生成的代码修改到项目文件
206 6. **日志记录**：保存完整的交互历史和文件修改
207 
208 ### GitHub自动化模式 (bot)
209 
210 1. **初始化**：创建临时工作目录
211 2. **分支管理**：创建或检出与Issue相关的分支
212 3. **需求处理**：与client模式相同，但在临时目录中操作
213 4. **代码提交**：自动提交代码修改
214 5. **拉取请求**：创建拉取请求到默认分支
215 6. **Issue回复**：在原Issue中添加处理结果的评论
216 7. **清理**：删除临时工作目录
217 
218 ## 输出与日志
219 
220 bella-issues-bot 生成以下输出：
221 
222 1. **控制台输出**：显示处理进度和结果
223 2. **日志文件**：保存在 `.eng/memory/issues/#<issue-id>/round_<num>/` 目录下
224    - `system_prompt.txt`：系统提示词
225    - `user_prompt.txt`：用户提示词
226    - `response.txt`：AI响应
227    - `diff/`：文件修改差异
228 
229 ## 最佳实践
230 
231 1. **明确需求**：提供清晰、具体的需求描述
232 2. **使用Issue ID**：为不同的需求使用不同的Issue ID
233 3. **初始化文件记忆**：首次使用前运行 `bella-file-memory`
234 4. **审查代码**：检查AI生成的代码，确保符合预期
235 5. **增量开发**：将复杂需求分解为多个小步骤
236 
237 ## 故障排除
238 
239 ### 常见问题
240 
241 1. **API密钥错误**：确保OPENAI_API_KEY环境变量正确设置
242 2. **Git错误**：检查Git配置和权限
243 3. **文件记忆问题**：如果文件描述不准确，尝试重新运行 `bella-file-memory`
244 4. **模型限制**：如果遇到模型容量限制，尝试将需求分解为更小的部分
245 
246 ### 日志和调试
247 
248 设置环境变量 `LOG_LEVEL=DEBUG` 可以获取更详细的日志输出，帮助诊断问题。
249 
250 ## 相关文档
251 
252 - [主项目文档](../README.md)
253 - [文件记忆系统文档](./README_FILE_MEMORY.md)
254 - [GitHub工作流文档](./README_GITHUB_WORKFLOWS.md)
```




# 用户需求

title：为版本管理创建一个examples

