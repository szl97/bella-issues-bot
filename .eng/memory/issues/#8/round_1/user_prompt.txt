# 项目文件描述


- README.md: bella-issues-bot项目的中文README文件，详细介绍了项目简介、主要功能、记忆系统（日志管理、版本管理、文件记忆）、安装方法、配置选项和详细使用示例，还包含项目结构说明，全面展示了这个AI代码开发助手的功能和用法。

- README.en.md: bella-issues-bot项目的英文README文件，介绍了项目概览、核心功能、记忆系统架构（LogManager、VersionManager和FileMemory）、安装方法和配置选项。重点说明了项目的两种工作模式和三大记忆组件的工作原理。

- quick-start.md: bella-issues-bot项目的中文使用指南，详细介绍了个人开发助手模式和GitHub工作流集成的使用方法，包括安装步骤、文件记忆系统初始化、命令行参数和环境变量配置等内容，帮助用户快速上手该工具。

- quick-start.en.md: bella-issues-bot项目的英文快速入门指南，简洁地介绍了基本设置、常见使用场景（个人助手和GitHub集成）、文件记忆系统操作、配置方法以及最佳实践，帮助英文用户迅速掌握工具的核心功能。

- client/README_GITHUB_WORKFLOWS.md: GitHub工作流生成器文档，详细介绍了如何使用bella-issues-bot自动生成GitHub Actions工作流配置。包含功能概述、命令行参数、工作流文件详解、配置要求、使用场景和自定义方法等内容。

- client/github_workflow_generator.py: GitHub工作流生成器模块，用于创建GitHub Actions工作流文件，实现bella-issues-bot与GitHub的集成。提供generate_workflow_files函数和命令行接口，可生成文件记忆初始化和Issue处理两种工作流配置文件。

- core/git_manager.py: Git操作管理模块，封装了与Git仓库交互的功能。包含GitConfig和GitManager两个主要类，提供克隆、拉取、推送、分支管理等Git操作。支持GitHub认证、Issue评论添加，并能处理仓库路径、远程URL和认证令牌，与GitHub工作流集成。

- scripts/generate_workflows.sh: Bash脚本，为bella-issues-bot集成提供命令行接口，包含帮助信息展示和参数传递功能。该脚本最终调用Python模块client.github_workflow_generator来实际生成工作流文件，支持设置输出目录、分支名称和模型参数等选项。

- pyproject.toml: 项目配置文件，定义了bella-issues-bot项目的元数据、依赖、脚本入口和代码风格规范。包含Poetry包管理配置、项目版本、依赖库列表以及代码格式化工具(ruff、black)的设置。


# 文件内容



```
File: README.md
1 # bella-issues-bot
2 
3 - [![Static Badge](https://img.shields.io/badge/deep-wiki-blue?style=flat-square)](https://deepwiki.com/bella-top/bella-issues-bot)
4 - [![Static Badge](https://img.shields.io/badge/Bella-support-%23C76300?style=flat-square)](https://doc.bella.top/)
5 
6 中文 | [English](./README.en.md)
7 
8 ## 项目简介
9 
10 bella-issues-bot 是一个基于人工智能的多功能代码开发助手，具备两种强大的工作模式：
11 
12 1. **个人开发助手模式**：在日常开发过程中，作为命令行工具辅助编码，帮助分析代码、生成实现、解决技术难题。
13 2. **GitHub自动化模式**：集成到GitHub工作流中，自动监控和处理项目Issues，无需人工干预即可分析需求、提出解决方案并实现代码变更。
14 
15 通过对项目结构的深入理解和强大的代码生成能力，bella-issues-bot 能够显著提高开发效率，减少重复工作，让您专注于更有创造性的任务。
16 
17 ## 主要功能
18 
19 - **需求分析**：自动理解和分解用户的功能需求，确定所需的代码修改
20 - **代码生成**：根据需求生成符合项目风格的代码，自动实现新功能或修复问题
21 - **版本管理**：与Git深度集成，支持分支创建、代码提交和拉取请求的自动管理
22 - **记忆系统**：记录项目文件描述和操作历史，提供上下文感知能力，持续改进代码质量
23 
24 ### 典型使用场景
25 
26 - **日常开发辅助**：在本地开发过程中，使用命令行工具快速生成代码、解决技术问题
27 - **项目自动化**：集成到GitHub工作流，实现Issue的自动处理和代码实现
28 - **代码文档生成**：自动分析项目文件并生成详细的功能描述
29 - **技术难题解决**：分析项目上下文后，针对性地提供解决方案
30 
31 ## 记忆与上下文管理
32 
33 bella-issues-bot 配备了强大的记忆系统，由三个核心组件构成：
34 
35 ### 记忆系统的工作流程
36 
37 1. **初始化阶段**：首次运行时，系统会扫描整个项目并为每个文件生成详细描述
38 2. **增量更新**：后续运行时，只会更新新增或修改的文件描述，提高效率
39 3. **上下文提取**：处理用户需求时，系统根据需求内容选择相关文件作为上下文
40 
41 ### 1. 日志管理 (LogManager)
42 
43 LogManager 负责记录每次交互的完整历史，包括：
44 - 系统提示词和用户需求
45 - AI响应内容
46 - 文件修改记录和差异对比
47 
48 这些日志按issue和轮次组织，支持历史追溯和问题诊断。每轮交互都会生成详细日志，便于追踪AI的决策过程和代码修改历史。
49 
50 ### 2. 版本管理 (VersionManager)
51 
52 VersionManager 提供智能的版本控制功能：
53 - 自动提取历史轮次的需求和响应
54 - 生成格式化的历史执行记录作为上下文
55 - 分析当前需求与历史需求的关系
56 - 根据需要执行版本回退操作
57 
58 系统会分析新需求与先前修改的关系，判断是否需要回滚，确保代码修改的连贯性和一致性。
59 
60 ### 3. 文件记忆 (FileMemory)
61 
62 FileMemory 模块为项目的每个文件维护详细描述：
63 - 自动生成文件功能、结构和关系描述
64 - 跟踪文件变更，更新受影响文件的描述
65 - 提供上下文相关的文件选择
66 - 支持配置忽略文件，默认包含项目的.gitignore，支持自定义添加.eng/.engignore
67 
68 这使得AI助手能够理解整个代码库的结构和功能，在修改代码时考虑到更广泛的项目上下文。
69 
70 ## 安装方法
71 
72 ### 通过 pip 安装
73 
74 ```bash
75 pip install bella-issues-bot
76 ```
77 
78 ### 从源码安装
79 
80 ```bash
81 git clone https://github.com/szl97/bella-issues-bot.git
82 cd bella-issues-bot
83 pip install -e .
84 ```
85 
86 ## 系统要求
87 
88 - Python 3.10 或更高版本（<3.13）
89 - Git 客户端（用于版本控制功能）
90 - OpenAI API 密钥（用于 AI 功能）
91 
92 ## 配置文件
93 
94 bella-issues-bot 支持多种配置方式：
95 
96 ### 环境变量配置
97 
98 工具会读取以下环境变量：
99 
100 - `OPENAI_API_KEY`: OpenAI API密钥（必需）
101 - `OPENAI_API_BASE`: OpenAI API基础URL（可选，用于自定义API端点）
102 - `GITHUB_REMOTE_URL`: GitHub远程仓库URL（可选，用于GitHub集成）
103 - `GITHUB_TOKEN`: GitHub身份验证令牌（可选，用于GitHub集成）
104 
105 ### 项目配置文件
106 
107 
108 - `.eng/system.txt`: 配置代码工程师的提示词
109 - `.eng/.engignore`: 类似于 `.gitignore`，用于指定文件记忆系统应忽略的文件
110 
111 示例 `.engignore` 文件:
112 ```
113 # 忽略所有日志文件
114 *.log
115 
116 # 忽略构建目录
117 /build/
118 /dist/
119 
120 # 忽略虚拟环境
121 /venv/
122 /.venv/
123 
124 # 忽略缓存文件
125 __pycache__/
126 *.py[cod]
127 *$py.class
128 ```
129 
130 ## 详细使用示例
131 
132 ### 0. 进入您的项目目录
133 
134 ### 1. 初始化文件记忆系统
135 
136 首次使用前，建议初始化文件记忆系统，这将帮助 AI 理解您的项目结构：
137 
138 ```bash
139 # 在项目根目录执行
140 bella-file-memory --project-dir .
141 ```
142 
143 这将分析您的项目文件并生成描述信息，存储在 `.eng/memory/file_details.txt` 中。
144 
145 ### 2. 作为个人开发助手使用
146 
147 ```bash
148 # 基本使用
149 bella-issues-bot --issue-id 123 --requirement "实现一个新的日志记录功能"
150 
151 # 使用自定义模型和温度
152 bella-issues-bot --issue-id 123 --requirement "优化文件读取性能" --core-model gpt-4o --core-temperature 0.5
153 ```
154 
155 ### 3. 设置 GitHub 工作流
156 
157 为您的项目生成 GitHub Actions 工作流配置：
158 
159 ```bash
160 # 生成默认工作流配置
161 bella-github-workflows
162 
163 # 自定义基础分支和模型
164 bella-github-workflows --base-branch develop --model gpt-4o
165 ```
166 
167 生成的工作流文件将保存在 `.github/workflows/` 目录中。
168 
169 ### 4. 使用编程 API
170 
171 ```python
172 from client.runner import run_workflow
173 
174 # 基本使用
175 run_workflow(
176     issue_id=123,
177     requirement="添加单元测试覆盖核心功能",
178     project_dir="./my_project"
179 )
180 
181 # 高级配置
182 run_workflow(
183     issue_id=123,
184     requirement="重构数据处理模块以提高性能",
185     project_dir="./my_project",
186     core_model="gpt-4o",
187     data_model="gpt-4o",
188     core_temperature=0.7,
189     data_temperature=0.5,
190     mode="client",  # 或 "bot" 用于 GitHub 自动化
191     max_retry=5
192 )
193 ```
194 
195 ## 项目结构
196 
197 ```
198 bella-issues-bot/
199 ├── core/               # 核心功能模块
200 │   ├── ai.py           # AI 助手接口
201 │   ├── file_memory.py  # 文件记忆系统
202 │   ├── git_manager.py  # Git 版本控制
203 │   └── workflow_engine.py  # 工作流引擎
204 ├── client/             # 客户端接口
205 │   ├── terminal.py     # 命令行界面
206 │   ├── file_memory_client.py  # 文件记忆客户端
207 │   └── github_workflow_generator.py  # GitHub 工作流生成器
208 └── examples/           # 使用示例
209 ```
210
```




```
File: README.en.md
1 # bella-issues-bot
2 
3 - [![Static Badge](https://img.shields.io/badge/deep-wiki-blue?style=flat-square)](https://deepwiki.com/bella-top/bella-issues-bot)
4 - [![Static Badge](https://img.shields.io/badge/Bella-support-%23C76300?style=flat-square)](https://doc.bella.top/)
5 
6 English | [中文](./README.md)
7 
8 ## Project Overview
9 
10 bella-issues-bot is an AI-powered multifunctional code development assistant that operates in two powerful modes:
11 
12 1. **Personal Development Assistant Mode**: Acts as a command-line tool during daily development, helping analyze code, generate implementations, and solve technical challenges.
13 2. **GitHub Automation Mode**: Integrates into GitHub workflows, automatically monitoring and handling project issues, analyzing requirements, proposing solutions, and implementing code changes without manual intervention.
14 
15 Through its deep understanding of project structure and powerful code generation capabilities, bella-issues-bot significantly improves development efficiency, reduces repetitive work, and lets you focus on more creative tasks.
16 
17 ## Key Features
18 
19 - **Requirement Analysis**: Automatically understands and breaks down user requirements to determine necessary code changes
20 - **Code Generation**: Generates code that matches project style, automatically implementing new features or fixing issues
21 - **Version Control**: Deep Git integration, supporting automated branch creation, code commits, and pull request management
22 - **Memory System**: Records project file descriptions and operation history, providing context-aware capabilities and continuous code quality improvement
23 
24 ### Typical Use Cases
25 
26 - **Daily Development Support**: Use command-line tools for quick code generation and technical problem-solving
27 - **Project Automation**: Integrate with GitHub workflows for automated issue handling and code implementation
28 - **Code Documentation Generation**: Automatically analyze project files and generate detailed functional descriptions
29 - **Technical Problem Resolution**: Provide targeted solutions after analyzing project context
30 
31 ## Memory and Context Management
32 
33 bella-issues-bot features a powerful memory system consisting of three core components:
34 
35 ### Memory System Workflow
36 
37 1. **Initialization Phase**: On first run, the system scans the entire project and generates detailed descriptions for each file
38 2. **Incremental Updates**: Subsequently, only updates descriptions for new or modified files, improving efficiency
39 3. **Context Extraction**: When processing user requirements, the system selects relevant files as context based on requirement content
40 
41 ### 1. Log Management (LogManager)
42 
43 LogManager records complete interaction history, including:
44 - System prompts and user requirements
45 - AI responses
46 - File modification records and diff comparisons
47 
48 Logs are organized by issue and iteration, supporting historical tracking and problem diagnosis.
49 
50 ### 2. Version Management (VersionManager)
51 
52 VersionManager provides intelligent version control features:
53 - Automatically extracts requirements and responses from historical iterations
54 - Generates formatted execution history as context
55 - Analyzes relationships between current and historical requirements
56 - Performs version rollbacks as needed
57 
58 ### 3. File Memory (FileMemory)
59 
60 FileMemory module maintains detailed descriptions for each project file:
61 - Automatically generates file functionality, structure, and relationship descriptions
62 - Tracks file changes and updates affected file descriptions
63 - Provides context-aware file selection
64 - Supports ignored files configuration, includes project's .gitignore by default, and supports custom .eng/.engignore
65 
66 ## Installation
67 
68 ### Via pip
69 
70 ```bash
71 pip install bella-issues-bot
72 ```
73 
74 ### From Source
75 
76 ```bash
77 git clone https://github.com/szl97/bella-issues-bot.git
78 cd bella-issues-bot
79 pip install -e .
80 ```
81 
82 ## System Requirements
83 
84 - Python 3.10 or higher (< 3.13)
85 - Git client (for version control features)
86 - OpenAI API key (for AI functionality)
87 
88 ## Configuration
89 
90 bella-issues-bot supports multiple configuration methods:
91 
92 ### Environment Variables
93 
94 The tool reads the following environment variables:
95 
96 - `OPENAI_API_KEY`: OpenAI API key (required)
97 - `OPENAI_API_BASE`: OpenAI API base URL (optional, for custom API endpoints)
98 - `GITHUB_REMOTE_URL`: GitHub repository URL (optional, for GitHub integration)
99 - `GITHUB_TOKEN`: GitHub authentication token (optional, for GitHub integration)
100 
101 ### Project Configuration Files
102 
103 - `.eng/system.txt`: Configure code engineer prompts
104 - `.eng/.engignore`: Similar to `.gitignore`, specifies files to be ignored by the memory system
105 
106 Example `.engignore` file:
107 ```
108 # Ignore all log files
109 *.log
110 
111 # Ignore build directories
112 /build/
113 /dist/
114 
115 # Ignore virtual environments
116 /venv/
117 /.venv/
118 
119 # Ignore cache files
120 __pycache__/
121 *.py[cod]
122 *$py.class
123 ```
124 
125 For detailed usage examples and project structure, please refer to the QUICK-START.md guide.
```




```
File: quick-start.md
1 # bella-issues-bot 使用指南
2 
3 中文 | [English](./quick-start.en.md)
4 
5 在GitHub上使用bella-issues-bot项目，您可以执行以下主要操作：
6 
7 ## 1. 作为个人开发助手
8 
9 ### 安装项目
10 ```bash
11 # 通过pip安装
12 pip install bella-issues-bot
13 
14 # 或从源码安装
15 git clone https://github.com/szl97/bella-issues-bot.git
16 cd bella-issues-bot
17 pip install -e .
18 ```
19 
20 ### 初始化文件记忆系统
21 ```bash
22 # 分析您的项目文件并生成描述信息
23 bella-file-memory --project-dir ./your-project
24 ```
25 
26 ### 使用AI助手处理需求
27 ```bash
28 # 基本使用 - 提出问题或请求代码修改
29 bella-issues-bot --issue-id 123 --requirement "实现一个新的日志记录功能"
30 
31 # 自定义模型和温度
32 bella-issues-bot --issue-id 123 --requirement "优化文件读取性能" --core-model gpt-4o --core-temperature 0.5
33 ```
34 
35 ## 2. 集成GitHub工作流
36 
37 ### 生成GitHub Actions工作流配置
38 ```bash
39 # 生成默认配置
40 bella-github-workflows
41 
42 # 自定义基础分支和模型
43 bella-github-workflows --base-branch develop --model gpt-4o
44 ```
45 
46 这将在`.github/workflows/`目录中创建两个工作流文件：
47 - `memory_init.yml` - 自动分析项目文件并维护文件记忆
48 - `issue_process.yml` - 自动处理Issue中的需求
49 
50 ### 配置GitHub仓库权限
51 
52 在仓库的Settings中设置：
53 1. 添加必要的Secrets（`OPENAI_API_KEY`）
54 2. 启用Actions的读写权限和PR创建权限
55 
56 ## 3. 使用GitHub Issues获取AI协助
57 
58 一旦集成了GitHub工作流，您可以：
59 
60 1. 创建一个新Issue描述您的需求
61 2. AI助手会自动：
62     - 分析您的需求
63     - 在专用分支上实现代码
64     - 创建拉取请求
65     - 在Issue中回复处理结果
66 
67 ## 4. 使用编程API
68 
69 在Python代码中使用：
70 
71 ```python
72 from client.runner import run_workflow
73 
74 # 处理需求并生成代码
75 run_workflow(
76     issue_id=123,
77     requirement="添加单元测试覆盖核心功能",
78     project_dir="./my_project",
79     core_model="gpt-4o"
80 )
81 ```
82 
83 ## 5. 配置项目
84 
85 ### 环境变量设置
86 ```
87 OPENAI_API_KEY=your_api_key
88 OPENAI_API_BASE=https://api.openai.com/v1  # 可选，自定义API端点
89 GITHUB_REMOTE_URL=https://github.com/username/repo.git  # 用于GitHub集成
90 GITHUB_TOKEN=your_github_token  # 用于GitHub集成
91 ```
92 
93 ### 项目配置文件
94 - `.eng/system.txt` - 自定义AI提示词
95 - `.eng/.engignore` - 类似`.gitignore`，指定记忆系统应忽略的文件
96 
97 bella-issues-bot提供了强大的AI代码开发助手功能，无论是作为个人开发工具还是GitHub自动化机器人，都能显著提高开发效率，减少重复工作。
```




```
File: quick-start.en.md
1 # Quick Start Guide
2 
3 English | [中文](./quick-start.md)
4 
5 This guide provides essential information to get started with bella-issues-bot quickly.
6 
7 ## Basic Setup
8 
9 1. Install the package:
10 ```bash
11 pip install bella-issues-bot
12 ```
13 
14 2. Set up environment variables:
15 ```bash
16 export OPENAI_API_KEY="your-api-key"
17 ```
18 
19 ## Common Use Cases
20 
21 ### 1. Personal Development Assistant
22 
23 Use bella-issues-bot as your coding assistant:
24 
25 ```bash
26 # Generate code implementation
27 bella-issues-bot --requirement "Create a function to calculate fibonacci numbers"
28 
29 # Analyze existing code
30 bella-issues-bot --requirement "Review and optimize this function" --file path/to/file.py
31 
32 # Fix bugs
33 bella-issues-bot --requirement "Fix the memory leak in this module" --file path/to/module.py
34 ```
35 
36 ### 2. GitHub Integration
37 
38 1. Create `.github/workflows/bella-bot.yml`:
39 
40 ```yaml
41 name: Bella Issues Bot
42 on:
43   issues:
44     types: [opened, edited]
45 
46 jobs:
47   process-issue:
48     runs-on: ubuntu-latest
49     steps:
50       - uses: actions/checkout@v2
51       - name: Run Bella Issues Bot
52         env:
53           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
54           OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
55         run: |
56           pip install bella-issues-bot
57           bella-issues-bot --mode github
58 ```
59 
60 2. Add repository secrets:
61    - Go to repository Settings > Secrets
62    - Add your `OPENAI_API_KEY`
63 
64 ### 3. File Memory System
65 
66 Initialize the file memory system for better context awareness:
67 
68 ```bash
69 # Initialize file memory
70 bella-file-memory --project-dir .
71 
72 # Update file memory after changes
73 bella-file-memory --project-dir . --update
74 ```
75 
76 ### 4. Configuration
77 
78 Create `.eng/.engignore` to exclude files from analysis:
79 
80 ```
81 # Example .engignore
82 node_modules/
83 dist/
84 *.log
85 ```
86 
87 ## Common Parameters
88 
89 - `--requirement`: The task or requirement description
90 - `--mode`: Operation mode (`client` or `github`)
91 - `--core-model`: AI model to use (default: gpt-4)
92 - `--core-temperature`: Model temperature (default: 0.7)
93 - `--project-dir`: Project directory path
94 
95 ## Best Practices
96 
97 1. **Clear Requirements**: Write clear, specific requirements for better results
98 2. **File Memory**: Initialize file memory before first use
99 3. **Version Control**: Always work in a clean git repository
100 4. **Context**: Provide relevant file paths when needed
101 5. **Regular Updates**: Keep the tool and file memory system updated
```




```
File: client/README_GITHUB_WORKFLOWS.md
1 # GitHub工作流生成器
2 
3 bella-issues-bot 提供了自动生成 GitHub Actions 工作流配置的功能，可以轻松将 AI 助手集成到您的 GitHub 项目中。
4 
5 ## 功能概述
6 
7 工作流生成器会创建两个GitHub Actions工作流文件：
8 
9 1. **记忆初始化工作流** (`memory_init.yml`)
10    - 当指定分支有推送时触发
11    - 会跳过机器人自身的提交（通过检查提交信息中的"Update file memory"）
12    - 分析项目文件并生成文件描述
13    - 将记忆文件提交回仓库
14 
15 2. **Issue处理工作流** (`issue_process.yml`)
16    - 在创建新Issue或添加评论时触发
17    - 自动提取Issue或评论中的需求
18    - 在专用分支上处理需求并实现代码
19    - 创建拉取请求，提供解决方案
20    - 在Issue中添加处理结果的评论
21 
22 ## 命令行使用方式
23 
24 运行以下命令生成GitHub工作流文件：
25 
26 ```bash
27 # 基本用法 - 使用默认配置
28 bella-github-workflows
29 
30 # 指定基础分支
31 bella-github-workflows --base-branch develop
32 
33 # 自定义模型和温度
34 bella-github-workflows --model gpt-4o --temperature 0.5
35 ```
36 
37 ### 命令行参数
38 
39 - `--output-dir`, `-o`: 输出目录，默认为 `.github/workflows`
40 - `--base-branch`, `-bb`: 拉取请求的目标分支，默认为 `main`
41 - `--model`, `-m`: 默认 AI 模型，默认为 `gpt-4o`
42 - `--core-model`, `--cm`: 核心操作使用的模型（如果与默认模型不同）
43 - `--data-model`, `--dm`: 数据操作使用的模型（如果与默认模型不同）
44 - `--temperature`, `-t`: 默认温度设置，默认为 `0.7`
45 - `--core-temperature`, `--ct`: 核心模型的温度（如果与默认温度不同）
46 - `--data-temperature`, `--dt`: 数据模型的温度（如果与默认温度不同）
47 - `--package-version`, `-v`: 指定安装的包版本，例如 `==0.1.1`
48 
49 ### 记忆初始化工作流 (`memory_init.yml`)
50 
51 此工作流在指定分支有推送时运行，它：
52 1. 检查提交是否由自动化机器人产生（含有"Update file memory"的提交信息）
53    - 如果是机器人提交，则会跳过执行，防止无限循环
54    - 可以通过workflow_dispatch手动触发并强制执行
55 2. 检出代码库
56 3. 设置Python环境
57 4. 安装bella-issues-bot
58 5. 初始化文件记忆系统，生成项目文件描述
59 6. 将生成的记忆文件提交回仓库（提交信息带有[skip memory]标记）
60 
61 ### Issue处理工作流 (`issue_process.yml`)
62 
63 此工作流在创建新Issue或添加评论时运行，具体步骤如下：
64 1. 检出代码库
65 2. 设置Python环境
66 3. 安装bella-issues-bot
67 4. 提取Issue或评论中的需求
68 5. 运行bella-issues-bot处理需求（它会自动创建分支并提交代码）
69    - 如果评论以"bella-issues-bot已处理："开头，则跳过处理
70 6. 创建拉取请求
71 7. 在Issue中添加处理结果的评论
72 
73 ## GitHub配置要求
74 
75 要使这些工作流正常运行，您需要在GitHub仓库的设置中配置以下内容：
76 
77 ### 1. Secrets 配置
78 
79 在仓库的 Settings > Secrets and variables > Actions 中添加以下 secrets：
80 
81 - `OPENAI_API_KEY`: 您的OpenAI API密钥（必需）
82 - `OPENAI_API_BASE`: 自定义API基础URL（可选）
83 - `GITHUB_TOKEN`: GitHub自动提供，无需手动配置
84 
85 ### 2. 权限设置
86 
87 在仓库的 Settings > Actions > General > Workflow permissions 中：
88 
89 - 选择 "Read and write permissions"
90 - 勾选 "Allow GitHub Actions to create and approve pull requests"
91 
92 ## 工作流文件详解
93 
94 ### 记忆初始化工作流 (`memory_init.yml`)
95 
96 ```yaml
97 name: Initialize File Memory
98 
99 on:
100   workflow_dispatch:  # 允许手动触发
101     inputs:
102       force_run:
103         description: '强制执行，即使是自动提交'
104   push:
105     branches:
106       - main  # 可自定义为您的默认分支
107 
108 jobs:
109   init-memory:
110     runs-on: ubuntu-latest
111     permissions:
112       contents: write
113     if: ${{ !contains(github.event.head_commit.message, '[skip memory]') || github.event_name == 'workflow_dispatch' }}
114     steps:
115       - name: 检出代码
116         uses: actions/checkout@v3
117         with:
118           fetch-depth: 0
119 
120       - name: 设置Python环境
121         uses: actions/setup-python@v4
122         with:
123           python-version: '3.10'
124           
125       - name: 安装依赖
126         run: pip install bella-issues-bot
127         
128       - name: 初始化文件记忆
129         env:
130            OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
131            OPENAI_API_BASE: ${{ secrets.OPENAI_API_BASE }}
132            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
133            GIT_REMOTE: ${{ github.server_url }}/${{ github.repository }}
134         run: bella-file-memory \
135               --mode bot \
136               --model gpt-4o \
137               -u "https://api.openai.com/v1" \
138               -k "sk-xxxxx" \
139               --git-url "https://github.com/szl97/bella-issues-bot.git" \
140               --git-token "githubxxxxx"
141 ```
142 
143 ### Issue处理工作流 (`issue_process.yml`)
144 
145 ```yaml
146 name: Process Issues with AI
147 
148 on:
149   issues:
150     types: [opened]
151   issue_comment:
152     types: [created]
153 
154 jobs:
155   process-issue:
156     runs-on: ubuntu-latest
157     if: ${{ !startsWith(github.event.comment.body, 'bella-issues-bot已处理：') }}
158     permissions:
159       contents: write
160       pull-requests: write
161       issues: write
162     steps:
163       - name: 检出代码
164         uses: actions/checkout@v3
165         with:
166           fetch-depth: 0
167           
168       - name: 设置Python环境
169         uses: actions/setup-python@v4
170         with:
171           python-version: '3.10'
172           
173       - name: 安装依赖
174         run: pip install bella-issues-bot
175         
176       - name: 处理Issue
177         env:
178            OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
179            OPENAI_API_BASE: ${{ secrets.OPENAI_API_BASE }}
180            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
181            GIT_REMOTE: ${{ github.server_url }}/${{ github.repository }}
182         run: |
183           # 提取Issue ID和需求
184           ISSUE_ID=${{ github.event.issue.number }}
185           REQUIREMENT="${{ github.event.issue.body || github.event.comment.body }}"
186           
187           # 运行bella-issues-bot处理需求
188           bella-issues-bot \
189             --issue-id $ISSUE_ID \
190             --requirement "$REQUIREMENT" \
191             --mode bot \
192             -u "https://api.openai.com/v1" \
193             -k "sk-xxxxx" \
194             --git-url "https://github.com/szl97/bella-issues-bot.git" \
195             --git-token "githubxxxxx"
196 ```
197 
198 ## 使用场景
199 
200 ### 1. 自动化需求实现
201 
202 当用户在GitHub Issues中提出新功能需求或报告bug时，bella-issues-bot可以：
203 - 自动分析需求
204 - 实现所需的代码更改
205 - 创建拉取请求
206 - 在Issue中提供详细的解决方案说明
207 
208 ### 2. 代码文档维护
209 
210 每当有新代码推送到主分支时，bella-issues-bot可以：
211 - 分析新增或修改的文件
212 - 更新文件功能描述
213 - 维护项目的知识库
214 
215 ### 3. 技术支持自动化
216 
217 当用户在Issues中提出技术问题时，bella-issues-bot可以：
218 - 分析问题
219 - 提供解决方案
220 - 生成示例代码
221 - 自动回复用户
222 
223 ## 自定义工作流
224 
225 您可以根据项目需求自定义工作流文件。以下是一些常见的自定义场景：
226 
227 ### 1. 触发条件自定义
228 
229 您可以修改工作流的触发条件，例如：
230 - 限制特定标签的Issues
231 - 只在特定分支上运行
232 - 添加定时触发
233 
234 ```yaml
235 on:
236   issues:
237     types: [opened, labeled]
238   issue_comment:
239     types: [created]
240   schedule:
241     - cron: '0 0 * * 1'  # 每周一运行
242 ```
243 
244 ### 2. 环境自定义
245 
246 您可以自定义Python版本或添加其他环境依赖：
247 
248 ```yaml
249 - name: 设置Python环境
250   uses: actions/setup-python@v4
251   with:
252     python-version: '3.11'
253     
254 - name: 安装额外依赖
255   run: |
256     pip install bella-issues-bot
257     pip install your-additional-package
258 ```
259 
260 ### 3. 通知自定义
261 
262 您可以添加Slack、Email或其他通知方式：
263 
264 ```yaml
265 - name: 发送Slack通知
266   uses: 8398a7/action-slack@v3
267   with:
268     status: ${{ job.status }}
269     fields: repo,message,commit,author,action,eventName,ref,workflow
270   env:
271     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
272   if: always()
273 ```
274 
275 ## 故障排除
276 
277 ### 常见问题
278 
279 1. **权限问题**：确保工作流有适当的权限（contents、issues、pull-requests）
280 2. **API密钥问题**：检查OPENAI_API_KEY是否正确设置
281 3. **提交循环**：如果遇到无限提交循环，检查提交消息过滤逻辑
282 4. **超时问题**：对于大型项目，可能需要增加工作流超时限制
283 
284 ### 日志和调试
285 
286 GitHub Actions提供了详细的日志，您可以在Actions标签页中查看每次运行的详细日志。
287 
288 ## 最佳实践
289 
290 1. **明确需求格式**：在项目文档中说明如何编写Issue以获得最佳结果
291 2. **定期更新依赖**：确保使用最新版本的bella-issues-bot
292 3. **审查自动生成的代码**：虽然AI生成的代码通常很好，但人工审查仍然重要
293 4. **设置适当的标签**：使用标签来标记适合AI处理的Issues
294 
295 ## 相关文档
296 
297 - [主项目文档](../README.md)
298 - [文件记忆系统文档](./README_FILE_MEMORY.md)
299 - [客户端文档](./README.md)
300
```




```
File: client/github_workflow_generator.py
1 """
2 GitHub Workflow Generator
3 
4 A module for generating GitHub Actions workflow files to integrate bella-issues-bot with GitHub.
5 Creates two workflows:
6 1. File Memory Initialization - Triggered on push to a configurable branch
7 2. Issue Processing Bot - Triggered when issues are created or commented on
8 """
9 
10 import argparse
11 import os
12 import sys
13 from pathlib import Path
14 from typing import Dict, Optional
15 
16 from core.log_config import get_logger, setup_logging
17 
18 logger = get_logger(__name__)
19 
20 # Template for memory initialization workflow
21 MEMORY_INIT_TEMPLATE = """name: Initialize File Memory
22 
23 on:
24   workflow_dispatch:  # Allow manual triggering
25     inputs:
26       force_run:
27         description: 'Force execution even for automated commits'
28   push:
29     branches:
30       - {branch}
31 
32 jobs:
33   init-memory:
34     runs-on: ubuntu-latest
35     permissions:
36       contents: write
37     if: ${{{{ !contains(github.event.head_commit.message, '[skip memory]') || github.event_name == 'workflow_dispatch' }}}}
38     steps:
39       - name: Checkout code
40         uses: actions/checkout@v3
41         with:
42           fetch-depth: 0
43 
44       - name: Set up Python
45         uses: actions/setup-python@v4
46         with:
47           python-version: '3.10'
48 
49       - name: Install bella-issues-bot
50         run: |
51           python -m pip install --upgrade pip
52           pip install bella-issues-bot{package_version}
53 
54       - name: Initialize file memory
55         env:
56           OPENAI_API_KEY: ${{{{ secrets.OPENAI_API_KEY }}}}
57           OPENAI_API_BASE: ${{{{ secrets.OPENAI_API_BASE }}}}
58           GIT_REMOTE: ${{{{ github.server_url }}}}/${{{{ github.repository }}}}
59           GITHUB_TOKEN: ${{{{ secrets.GIT_TOKEN }}}}
60         run: |
61           bella-file-memory --mode bot -b {branch} -m {model} -t {temperature} --git-url "${{{{ github.server_url }}}}/${{{{ github.repository }}}}" --git-token "${{{{ secrets.GIT_TOKEN }}}}" -u "${{{{ secrets.OPENAI_API_BASE }}}}" -k "${{{{ secrets.OPENAI_API_KEY }}}}"
62 """
63 
64 # Template for issue processing workflow
65 ISSUE_PROCESS_TEMPLATE = """name: Process Issues with bella-issues-bot
66 
67 on:
68   issues:
69     types: [opened]
70   issue_comment:
71     types: [created]
72 
73 jobs:
74   process-issue:
75     runs-on: ubuntu-latest
76     permissions:
77       contents: write
78       issues: write
79     if: ${{ (github.event_name == 'issues' && !endsWith(github.event.issue.title, '[skip-bot]')) || (github.event_name == 'issue_comment' && !startsWith(github.event.comment.body, 'bella-issues-bot已处理：') && !endsWith(github.event.issue.title, '[skip-bot]')) }}
80     steps:
81       - name: Checkout code
82         uses: actions/checkout@v3
83         with:
84           fetch-depth: 0
85 
86       - name: Set up Python
87         uses: actions/setup-python@v4
88         with:
89           python-version: '3.10'
90 
91       - name: Install bella-issues-bot
92         run: |
93           python -m pip install --upgrade pip
94           pip install bella-issues-bot{package_version}
95 
96       - name: Extract issue info
97         id: issue
98         run: |
99           if [[ "${{{{ github.event_name }}}}" == "issues" ]]; then
100             echo "issue_id=${{{{ github.event.issue.number }}}}" >> $GITHUB_OUTPUT
101             echo "requirement<<EOF" >> $GITHUB_OUTPUT
102             echo "title：${{{{ github.event.issue.title }}}}" >> $GITHUB_OUTPUT
103             echo "" >> $GITHUB_OUTPUT
104             echo "${{{{ github.event.issue.body }}}}" >> $GITHUB_OUTPUT
105             echo "EOF" >> $GITHUB_OUTPUT
106           else
107             echo "issue_id=${{{{ github.event.issue.number }}}}" >> $GITHUB_OUTPUT
108             echo "requirement<<EOF" >> $GITHUB_OUTPUT
109             echo "${{{{ github.event.comment.body }}}}" >> $GITHUB_OUTPUT
110             echo "EOF" >> $GITHUB_OUTPUT
111           fi
112 
113       - name: Process issue with bella-issues-bot
114         env:
115           OPENAI_API_KEY: ${{{{ secrets.OPENAI_API_KEY }}}}
116           OPENAI_API_BASE: ${{{{ secrets.OPENAI_API_BASE }}}}
117           GIT_REMOTE: ${{{{ github.server_url }}}}/${{{{ github.repository }}}}
118           GITHUB_TOKEN: ${{{{ secrets.GIT_TOKEN }}}}
119           ISSUE_ID: ${{{{ steps.issue.outputs.issue_id }}}}
120         run: |
121           # Run bella-issues-bot in bot mode - it will handle branch creation and pushing
122           bella-issues-bot --mode bot -b {base_branch} --issue-id ${{{{ steps.issue.outputs.issue_id }}}} --core-model {core_model} --data-model {data_model} --core-temperature {core_temperature} --data-temperature {data_temperature} --requirement "${{{{ steps.issue.outputs.requirement }}}}" --git-url "${{{{ github.server_url }}}}/${{{{ github.repository }}}}" --git-token "${{{{ secrets.GIT_TOKEN }}}}" -u "${{{{ secrets.OPENAI_API_BASE }}}}" -k "${{{{ secrets.OPENAI_API_KEY }}}}"
123 """
124 
125 def generate_workflow_files(
126     output_dir: str,
127     base_branch: str = "main",
128     model: str = "gpt-4o",
129     core_model: Optional[str] = None,
130     data_model: Optional[str] = None,
131     temperature: float = 0.7,
132     core_temperature: Optional[float] = None,
133     data_temperature: Optional[float] = None,
134     package_version: str = ""
135 ) -> Dict[str, str]:
136     """
137     Generate GitHub workflow YAML files.
138     
139     Args:
140         output_dir: Directory to write workflow files
141         base_branch: Base branch for pull requests
142         model: Default model to use for all operations
143         core_model: Model for core operations (if different from model)
144         data_model: Model for data operations (if different from model)
145         temperature: Default temperature setting for all models
146         core_temperature: Temperature for core model (if different)
147         data_temperature: Temperature for data model (if different)
148         package_version: Specific version of package to install (e.g. "==0.1.1")
149         
150     Returns:
151         Dictionary mapping file paths to their contents
152     """
153     workflows_dir = os.path.join(output_dir, ".github", "workflows")
154     os.makedirs(workflows_dir, exist_ok=True)
155     
156     # Format version specification if provided
157     if package_version and not package_version.startswith("=="):
158         package_version = f"=={package_version}"
159     
160     # Use provided models or default to the general model
161     actual_core_model = core_model or model
162     actual_data_model = data_model or model
163     
164     # Use provided temperatures or default to the general temperature
165     actual_core_temp = core_temperature if core_temperature is not None else temperature
166     actual_data_temp = data_temperature if data_temperature is not None else temperature
167     
168     # Generate memory initialization workflow
169     memory_workflow_path = os.path.join(workflows_dir, "memory_init.yml")
170     memory_workflow_content = MEMORY_INIT_TEMPLATE.format(
171         branch=base_branch,
172         model=actual_data_model,
173         temperature=actual_data_temp,
174         package_version=package_version
175     )
176     
177     # Generate issue processing workflow
178     issue_workflow_path = os.path.join(workflows_dir, "issue_process.yml")
179     issue_workflow_content = ISSUE_PROCESS_TEMPLATE.format(
180         core_model=actual_core_model,
181         data_model=actual_data_model,
182         core_temperature=actual_core_temp,
183         data_temperature=actual_data_temp,
184         base_branch=base_branch,
185         package_version=package_version
186     )
187     
188     # Write the files
189     with open(memory_workflow_path, 'w') as f:
190         f.write(memory_workflow_content)
191     
192     with open(issue_workflow_path, 'w') as f:
193         f.write(issue_workflow_content)
194     
195     logger.info(f"Generated workflow files in {workflows_dir}")
196     
197     return {
198         memory_workflow_path: memory_workflow_content,
199         issue_workflow_path: issue_workflow_content
200     }
201 
202 def main() -> None:
203     """Command line interface for GitHub workflow generator."""
204     parser = argparse.ArgumentParser(description="Generate GitHub Actions workflows for bella-issues-bot integration")
205     parser.add_argument("--output", "-o", type=str, default=".", help="Output directory (default: current directory)")
206     parser.add_argument("--base-branch", "-b", type=str, default="main", help="Base branch for pull requests (default: main)")
207     parser.add_argument("--model", "-m", type=str, default="gpt-4o", help="Default model for all operations (default: gpt-4o)")
208     parser.add_argument("--core-model", "--cm", type=str, help="Model for core operations (defaults to --model)")
209     parser.add_argument("--data-model", "--dm", type=str, help="Model for data operations (defaults to --model)")
210     parser.add_argument("--temperature", "-t", type=float, default=0.7, help="Default temperature for all models (default: 0.7)")
211     parser.add_argument("--core-temperature", "--ct", type=float, help="Temperature for core model (defaults to --temperature)")
212     parser.add_argument("--data-temperature", "--dt", type=float, help="Temperature for data model (defaults to --temperature)")
213     parser.add_argument("--package-version", "-v", type=str, default="", help="Specific package version to install (e.g. '0.1.1')")
214     parser.add_argument("--log-level", "-l", type=str, choices=["DEBUG", "INFO", "WARNING", "ERROR"], default="INFO", help="Logging level")
215     
216     args = parser.parse_args()
217     
218     # Setup logging
219     import logging
220     setup_logging(log_level=getattr(logging, args.log_level))
221     
222     # Generate workflow files
223     try:
224         generate_workflow_files(
225             output_dir=args.output,
226             base_branch=args.base_branch,
227             model=args.model,
228             core_model=args.core_model,
229             data_model=args.data_model,
230             temperature=args.temperature,
231             core_temperature=args.core_temperature,
232             data_temperature=args.data_temperature,
233             package_version=args.package_version
234         )
235         logger.info("Successfully generated GitHub workflow files")
236     except Exception as e:
237         logger.error(f"Error generating workflow files: {str(e)}")
238         sys.exit(1)
239 
240 if __name__ == "__main__":
241     main()
242
```




```
File: core/git_manager.py
1 import os
2 import shutil
3 from dataclasses import dataclass
4 from typing import Optional, List
5 from urllib.parse import urlparse, urlunparse
6 
7 import git
8 
9 from core.log_config import get_logger
10 
11 logger = get_logger(__name__)
12 
13 
14 @dataclass
15 class GitConfig:
16     """Git configuration parameters"""
17 
18     repo_path: str
19     remote_name: str = "origin"
20     default_branch: str = "main"
21     remote_url: Optional[str] = os.getenv("GIT_REMOTE")
22     auth_token: Optional[str] = os.getenv("GITHUB_TOKEN")
23 
24 
25 class GitManager:
26     """Manages git operations including push, pull, branch creation and switching"""
27 
28     def __init__(self, config: GitConfig):
29         """Initialize GitManager with configuration"""
30         self.config = config
31         self.repo = None
32         self._ensure_repo()
33 
34     def _ensure_repo(self) -> None:
35         """Ensure git repository exists and is properly initialized"""
36         if not os.path.exists(self.config.repo_path) or len(os.listdir(self.config.repo_path)) == 0:
37             if self.config.remote_url:
38                 self.clone()
39             else:
40                 raise ValueError(
41                     f"Repository path does not exist: {self.config.repo_path}"
42                 )
43         else:
44             try:
45                 self.repo = git.Repo(self.config.repo_path)
46                 # Set auth token for remote operations if provided
47                 if self.config.auth_token and self.config.remote_url:
48                     self._set_remote_with_auth()
49             except git.InvalidGitRepositoryError:
50                 raise ValueError(
51                     f"Invalid git repository at: {self.config.repo_path}"
52                 )
53 
54 
55 
56     def _get_url_with_token(self, url: str) -> str:
57         """
58         Insert authentication token into git URL
59 
60         Args:
61             url: Original git URL
62 
63         Returns:
64             URL with authentication token
65         """
66         if not self.config.auth_token:
67             return url
68 
69         parsed = urlparse(url)
70 
71         # Handle different URL formats
72         if parsed.scheme in ["http", "https"]:
73             netloc = f"{self.config.auth_token}@{parsed.netloc}"
74             return urlunparse(
75                 (
76                     parsed.scheme,
77                     netloc,
78                     parsed.path,
79                     parsed.params,
80                     parsed.query,
81                     parsed.fragment,
82                 )
83             )
84         elif "@" in url and ":" in url and url.startswith("git@"):  # Handle SSH format: git@github.com:username/repo.git
85             return url  # Don't modify SSH URLs
86         else:
87             return url  # Return original if format is not recognized
88 
89     def _set_remote_with_auth(self) -> None:
90         """Configure remote with authentication token"""
91         if not self.repo or not self.config.auth_token or not self.config.remote_url:
92             return
93 
94         try:
95             # Get current remotes
96             remotes = list(self.repo.remotes)
97             remote_exists = any(
98                 remote.name == self.config.remote_name for remote in remotes
99             )
100 
101             # Prepare URL with token
102             url_with_token = self._get_url_with_token(self.config.remote_url)
103 
104             # Set or update remote
105             if remote_exists:
106                 self.repo.git.remote("set-url", self.config.remote_name, url_with_token)
107             else:
108                 self.repo.git.remote("add", self.config.remote_name, url_with_token)
109 
110             logger.info(
111                 f"Configured remote '{self.config.remote_name}' with authentication"
112             )
113         except git.GitCommandError as e:
114             logger.error(f"Failed to configure remote with authentication: {str(e)}")
115             raise
116 
117     def clone(self) -> None:
118         """
119         Clone the repository specified in config
120 
121         Raises:
122             ValueError: If remote_url is not set in config
123             git.GitCommandError: If clone operation fails
124         """
125         if not self.config.remote_url:
126             raise ValueError("Remote URL must be set to clone a repository")
127 
128         self._clone_repo(branch=self.config.default_branch)
129 
130     def _clone_repo(self, branch: Optional[str] = None) -> None:
131         """
132         Internal method to perform the clone operation
133 
134         Args:
135             branch: Branch to checkout after cloning
136         """
137         try:
138             # Prepare parent directory if it doesn't exist
139             parent_dir = os.path.dirname(self.config.repo_path)
140             if parent_dir and not os.path.exists(parent_dir):
141                 os.makedirs(parent_dir)
142 
143             # Remove target directory if it exists
144             if os.path.exists(self.config.repo_path):
145                 shutil.rmtree(self.config.repo_path)
146 
147             # Prepare URL with token if provided
148             clone_url = self._get_url_with_token(self.config.remote_url)
149 
150             # Clone options
151             clone_args = {
152                 "url": clone_url,
153                 "to_path": self.config.repo_path,
154             }
155 
156             # Add branch if specified
157             if branch:
158                 clone_args["branch"] = branch
159 
160             # Clone the repository
161             self.repo = git.Repo.clone_from(**clone_args)
162 
163             logger.info(f"Successfully cloned repository to {self.config.repo_path}")
164 
165             # Configure remote with auth token if provided
166             if self.config.auth_token:
167                 self._set_remote_with_auth()
168 
169         except git.GitCommandError as e:
170             logger.error(f"Failed to clone repository: {str(e)}")
171             # Clean up if clone failed
172             if os.path.exists(self.config.repo_path):
173                 shutil.rmtree(self.config.repo_path)
174             raise
175 
176     def pull(self, branch: Optional[str] = None) -> None:
177         """
178         Pull changes from remote repository
179 
180         Args:
181             branch: Branch to pull from. If None, pulls current branch
182         """
183         try:
184             if branch:
185                 self.repo.git.pull(self.config.remote_name, branch)
186             else:
187                 self.repo.git.pull()
188             logger.info(
189                 f"Successfully pulled changes from {branch or 'current branch'}"
190             )
191         except git.GitCommandError as e:
192             logger.error(f"Failed to pull changes: {str(e)}")
193             raise
194 
195     def push(
196         self,
197         branch: Optional[str] = None,
198         force: bool = False,
199         set_upstream: bool = True,
200     ) -> None:
201         """
202         Push changes to remote repository
203 
204         Args:
205             branch: Branch to push. If None, pushes current branch
206             force: Whether to force push
207             set_upstream: Whether to set upstream branch if it doesn't exist
208         """
209         try:
210             # 确保远程 URL 包含认证令牌
211             if self.config.auth_token:
212                 self._set_remote_with_auth()
213 
214             # 如果没有指定分支，获取当前分支
215             current_branch = branch or self.get_current_branch()
216 
217             # 执行推送操作
218             if force:
219                 if set_upstream:
220                     self.repo.git.push(
221                         "-f", "--set-upstream", self.config.remote_name, current_branch
222                     )
223                 else:
224                     if branch:
225                         self.repo.git.push("-f", self.config.remote_name, branch)
226                     else:
227                         self.repo.git.push("-f")
228             else:
229                 if set_upstream:
230                     self.repo.git.push(
231                         "--set-upstream", self.config.remote_name, current_branch
232                     )
233                 else:
234                     if branch:
235                         self.repo.git.push(self.config.remote_name, branch)
236                     else:
237                         self.repo.git.push()
238 
239             logger.info(f"Successfully pushed changes to {current_branch}")
240         except git.GitCommandError as e:
241             logger.error(f"Failed to push changes: {str(e)}")
242             raise
243 
244     def create_branch(
245         self, branch_name: str, start_point: Optional[str] = None
246     ) -> None:
247         """
248         Create a new branch
249 
250         Args:
251             branch_name: Name of the new branch
252             start_point: Branch/commit to create branch from. If None, uses current HEAD
253         """
254         try:
255             if start_point:
256                 self.repo.git.branch(branch_name, start_point)
257             else:
258                 self.repo.git.branch(branch_name)
259             logger.info(f"Successfully created branch: {branch_name}")
260         except git.GitCommandError as e:
261             logger.error(f"Failed to create branch: {str(e)}")
262             raise
263 
264     def switch_branch(self, branch_name: str, create: bool = False) -> None:
265         """
266         Switch to specified branch
267 
268         Args:
269             branch_name: Name of the branch to switch to
270             create: Create branch if it doesn't exist
271         """
272         try:
273             if create:
274                 try:
275                     self.repo.git.checkout("-b", branch_name)
276                 except:
277                     self.repo.git.checkout(branch_name)
278             else:
279                 self.repo.git.checkout(branch_name)
280             logger.info(f"Successfully switched to branch: {branch_name}")
281         except git.GitCommandError as e:
282             logger.error(f"Failed to switch branch: {str(e)}")
283             raise
284 
285     def delete_branch(self, branch_name: str, force: bool = False) -> None:
286         """
287         Delete specified branch
288 
289         Args:
290             branch_name: Name of the branch to delete
291             force: Force delete even if branch not fully merged
292         """
293         try:
294             if force:
295                 self.repo.git.branch("-D", branch_name)
296             else:
297                 self.repo.git.branch("-d", branch_name)
298             logger.info(f"Successfully deleted branch: {branch_name}")
299         except git.GitCommandError as e:
300             logger.error(f"Failed to delete branch: {str(e)}")
301             raise
302 
303     def get_current_branch(self) -> str:
304         """Get name of current branch"""
305         return self.repo.active_branch.name
306 
307     def list_branches(self, remote: bool = False) -> List[str]:
308         """
309         List all branches
310 
311         Args:
312             remote: Whether to list remote branches instead of local
313 
314         Returns:
315             List of branch names
316         """
317         if remote:
318             return [ref.name for ref in self.repo.remote().refs]
319         return [branch.name for branch in self.repo.heads]
320 
321     def get_current_commit_id(self) -> str:
322         """获取当前提交的 ID"""
323         try:
324             return self.repo.head.commit.hexsha
325         except Exception as e:
326             logger.error(f"获取当前提交 ID 失败: {str(e)}")
327             return ""
328 
329     def get_changed_files(self, old_commit: str, new_commit: str) -> List[str]:
330         """
331         获取两个提交之间变更的文件列表
332 
333         Args:
334             old_commit: 旧提交的 ID
335             new_commit: 新提交的 ID
336 
337         Returns:
338             变更的文件路径列表
339         """
340         try:
341             # 获取提交对象
342             old = self.repo.commit(old_commit)
343             new = self.repo.commit(new_commit)
344 
345             # 获取差异
346             diff_index = old.diff(new)
347 
348             # 收集所有变更的文件
349             changed_files = set()
350 
351             # 添加修改的文件
352             for diff in diff_index.iter_change_type("M"):
353                 if not self.is_ignore(diff.a_path):
354                     changed_files.add(diff.a_path)
355 
356             # 添加增加的文件
357             for diff in diff_index.iter_change_type("A"):
358                 if not self.is_ignore(diff.b_path):
359                     changed_files.add(diff.b_path)
360 
361             # 添加删除的文件
362             for diff in diff_index.iter_change_type("D"):
363                 if not self.is_ignore(diff.b_path):
364                     changed_files.add(diff.a_path)
365 
366             return list(changed_files)
367         except Exception as e:
368             logger.error(f"获取变更文件列表失败: {str(e)}")
369             return []
370 
371     def is_ignore(self, path: str) -> bool:
372         # 检查文件名是否以点开头
373         file_name = os.path.basename(path)
374         if file_name.startswith("."):
375             return True
376         # 检查路径中是否包含以点开头的目录
377         path_parts = path.split(os.path.sep)
378         for part in path_parts:
379             # 跳过空字符串（可能出现在路径开头）
380             if not part:
381                 continue
382             # 如果目录名以点开头，则忽略
383             if part.startswith("."):
384                 return True
385 
386         # 如果不满足任何忽略条件，则不忽略
387         return False
388 
389     def delete_local_repository(self, remove_git_config: bool = False) -> None:
390         """
391         删除本地代码仓库和可选的全局 git 配置
392 
393         Args:
394             remove_git_config: 是否同时删除与此仓库相关的全局 git 配置
395 
396         Raises:
397             ValueError: 如果仓库路径不存在
398             OSError: 如果删除操作失败
399         """
400         if not os.path.exists(self.config.repo_path):
401             logger.warning(f"仓库路径不存在，无需删除: {self.config.repo_path}")
402             return
403 
404         try:
405             # 关闭仓库连接以释放文件锁
406             if self.repo:
407                 self.repo.close()
408                 self.repo = None
409 
410             # 删除本地仓库目录
411             shutil.rmtree(self.config.repo_path)
412             logger.info(f"成功删除本地仓库: {self.config.repo_path}")
413 
414             # 可选：删除全局 git 配置中与此仓库相关的条目
415             if remove_git_config:
416                 self._remove_git_config()
417 
418         except (OSError, shutil.Error) as e:
419             logger.error(f"删除本地仓库失败: {str(e)}")
420             raise
421 
422     def _remove_git_config(self) -> None:
423         """
424         从全局 git 配置中删除与当前仓库相关的配置
425 
426         这包括：
427         - 与远程仓库 URL 相关的凭证
428         - 特定于此仓库的用户配置
429         """
430         try:
431             # 获取仓库的规范路径
432             repo_path = os.path.abspath(self.config.repo_path)
433             repo_name = os.path.basename(repo_path)
434 
435             # 尝试从 git 配置中删除与此仓库相关的条目
436             if self.config.remote_url:
437                 # 解析远程 URL 以获取主机名
438                 parsed = urlparse(self.config.remote_url)
439                 if parsed.netloc:
440                     # 尝试删除凭证
441                     try:
442                         git.cmd.Git().execute(
443                             ["git", "credential", "reject"],
444                             input=f"url={self.config.remote_url}\n\n",
445                         )
446                         logger.info(f"已尝试从凭证存储中删除 {parsed.netloc} 的凭证")
447                     except git.GitCommandError:
448                         logger.debug("凭证删除操作未成功，可能没有存储凭证")
449 
450             # 尝试删除仓库特定的配置（如果有）
451             try:
452                 git.cmd.Git().execute(
453                     [
454                         "git",
455                         "config",
456                         "--global",
457                         "--remove-section",
458                         f"remote.{repo_name}",
459                     ]
460                 )
461                 logger.info(f"已删除全局 git 配置中的 remote.{repo_name} 部分")
462             except git.GitCommandError:
463                 logger.debug(f"全局配置中没有 remote.{repo_name} 部分")
464 
465             logger.info("已完成 git 配置清理")
466 
467         except Exception as e:
468             logger.warning(f"清理 git 配置时出错: {str(e)}")
469             # 不抛出异常，因为这是次要操作
470 
471     def add_issue_comment(self, issue_number: int, comment_text: str) -> bool:
472         """
473         在 GitHub 仓库的指定 Issue 下添加评论
474 
475         Args:
476             issue_number: Issue 编号
477             comment_text: 评论内容
478 
479         Returns:
480             bool: 操作是否成功
481 
482         Raises:
483             ValueError: 如果未配置认证令牌或远程 URL
484             Exception: 如果添加评论过程中发生其他错误
485         """
486         try:
487             # 检查必要的配置
488             if not self.config.auth_token:
489                 raise ValueError("添加 Issue 评论需要认证令牌 (auth_token)")
490 
491             if not self.config.remote_url:
492                 raise ValueError("添加 Issue 评论需要远程仓库 URL (remote_url)")
493 
494             # 导入 PyGithub
495             try:
496                 from github import Github
497             except ImportError:
498                 raise ImportError("添加 Issue 评论需要安装 PyGithub 库: pip install PyGithub")
499 
500             # 解析仓库所有者和名称
501             parsed_url = urlparse(self.config.remote_url)
502             path_parts = parsed_url.path.strip("/").split("/")
503 
504             if len(path_parts) < 2 or not all(path_parts[:2]):
505                 raise ValueError(f"无法从 URL 解析仓库所有者和名称: {self.config.remote_url}")
506 
507             owner = path_parts[0]
508             repo_name = path_parts[1]
509             if repo_name.endswith(".git"):
510                 repo_name = repo_name[:-4]  # 移除 .git 后缀
511 
512             # 初始化 GitHub 客户端
513             g = Github(self.config.auth_token)
514 
515             # 获取仓库和 Issue
516             repo = g.get_repo(f"{owner}/{repo_name}")
517             issue = repo.get_issue(issue_number)
518 
519             # 添加评论
520             comment = issue.create_comment(f"bella-issues-bot已处理：\n{comment_text}")
521 
522             logger.info(f"成功在 Issue #{issue_number} 下添加评论 (ID: {comment.id})")
523             return True
524 
525         except Exception as e:
526             logger.error(f"添加 Issue 评论失败: {str(e)}")
527             raise
528 
529     def commit(
530         self, message: str, add_all: bool = True, files: Optional[List[str]] = None
531     ) -> str:
532         """
533         创建一个新的提交
534 
535         Args:
536             message: 提交信息
537             add_all: 是否添加所有变更的文件，默认为 True
538             files: 要添加的特定文件列表，如果 add_all 为 True 则忽略此参数
539 
540         Returns:
541             str: 新提交的 SHA 哈希值
542 
543         Raises:
544             git.GitCommandError: 如果 Git 操作失败
545         """
546         try:
547             # 添加文件到暂存区
548             if add_all:
549                 self.repo.git.add(A=True)
550             elif files:
551                 for file in files:
552                     self.repo.git.add(file)
553 
554             # 创建提交
555             commit = self.repo.index.commit(message)
556             logger.info(f"成功创建提交: {commit.hexsha[:7]} - {message}")
557 
558             return commit.hexsha
559         except git.GitCommandError as e:
560             logger.error(f"创建提交失败: {str(e)}")
561             raise
562 
563     def reset_to(self, target_branch: str) -> bool:
564         """
565         将当前分支重置到远程目标分支的状态
566 
567         Args:
568             target_branch: 目标分支名称
569 
570         Returns:
571             bool: 操作是否成功
572         """
573         try:
574             # 获取远程分支
575             remote_name = self.config.remote_name
576             remote_branches = self.list_branches(remote=True)
577             remote_target = f"{remote_name}/{target_branch}"
578             # 检查目标分支是否存在于远端
579             if remote_target not in remote_branches:
580                 logger.warning(f"目标分支 {remote_target} 不存在于远端")
581                 return False
582 
583             # 切换到目标分支，如果不存在则创建
584             logger.info(f"切换到分支: {target_branch}")
585             self.switch_branch(target_branch, create=True)
586 
587             # 强制重置到远程分支状态
588             logger.info(f"重置到远程分支: {remote_target}")
589             self.repo.git.reset(f"{remote_target}", hard=True)
590             self.pull(target_branch)
591             logger.info(f"成功重置到版本: {target_branch}")
592             return True
593         except git.GitCommandError as e:
594             logger.error(f"重置到分支 {target_branch} 失败: {str(e)}")
595             return False
596         except Exception as e:
597             logger.error(f"重置过程中发生未知错误: {str(e)}")
598             return False
599 
600     def reset_to_issue_branch(self, issue_id: int) -> str:
601         """
602         拉取指定issue对应的最新分支并切换到该分支
603         如果该issue还未创建过分支，则切换到默认分支
604 
605         Args:
606             issue_id: Issue编号
607 
608         Returns:
609             str: 成功切换到的分支名称
610 
611         Raises:
612             git.GitCommandError: 如果Git操作失败
613         """
614         try:
615             # 确保远程仓库信息是最新的
616             self.repo.git.fetch(self.config.remote_name)
617             logger.info(f"成功获取远程仓库信息")
618             
619             # 获取所有远程分支
620             remote_branches = self.repo.git.branch("-r").splitlines()
621             remote_branches = [branch.strip() for branch in remote_branches]
622             
623             # 查找与指定issue相关的分支
624             issue_branch_name = f"bella-issues-bot-{issue_id}"
625             remote_issue_branch = f"{self.config.remote_name}/{issue_branch_name}"
626             
627             branch_exists = False
628             for branch in remote_branches:
629                 if remote_issue_branch in branch:
630                     branch_exists = True
631                     break
632 
633             if branch_exists:
634                 # 切换到issue分支
635                 self.reset_to(issue_branch_name)
636             else:
637                 self.pull()
638                 self.switch_branch(issue_branch_name, create=True)
639             logger.info(f"成功切换到issue #{issue_id}的分支: {issue_branch_name}")
640             
641             return issue_branch_name
642         except git.GitCommandError as e:
643             logger.error(f"切换到issue分支时出错: {str(e)}")
644             raise
645
```




```
File: scripts/generate_workflows.sh
1 #!/bin/bash
2 
3 # Script to generate GitHub workflow files for bella-issues-bot integration
4 # This script provides a simple interface to the workflow generator
5 
6 show_help() {
7     echo "Usage: $0 [options]"
8     echo ""
9     echo "Options:"
10     echo "  -o, --output DIR        Output directory (default: current directory)"
11     echo "  -b, --base-branch      Base branch for pull requests (default: main) "
12     echo "  -m, --model MODEL       Default model for all operations (default: gpt-4o)"
13     echo "  -t, --temp VALUE        Default temperature setting (default: 0.7)"
14     echo "  -v, --version VERSION   Specific package version to install (e.g. '0.1.1')"
15     echo "  -h, --help              Show this help message"
16     echo ""
17     echo "Additional options like --core-model, --data-model, etc. are also supported."
18     echo "Run 'bella-github-workflows --help' for complete details."
19     echo ""
20 }
21 
22 # Check if script can be executed on current system
23 check_requirements() {
24     if ! command -v python &> /dev/null; then
25         echo "Error: Python is required but not found"
26         exit 1
27     fi
28 }
29 check_requirements
30 
31 if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
32     show_help
33     exit 0
34 fi
35 
36 # Pass all arguments to the Python module
37 python -m client.github_workflow_generator "$@"
38
```




```
File: pyproject.toml
1 [tool.poetry]
2 name = "bella-issues-bot"
3 version = "0.1.21"
4 description = "bella-issues-bot 是一个基于人工智能的多功能代码开发助手，具备两种强大的工作模式：个人开发助手模式：在日常开发过程中，作为命令行工具辅助编码，帮助分析代码、生成实现、解决技术难题。GitHub自动化模式：集成到GitHub工作流中，自动监控和处理项目Issues，无需人工干预即可分析需求、提出解决方案并实现代码变更。"
5 authors = ["saizhuolin"]
6 license = "MIT"
7 readme = "README.md"
8 homepage = "https://github.com/szl97/bella-issues-bot"
9 repository = "https://github.com/szl97/bella-issues-bot"
10 documentation = "https://github.com/szl97/bella-issues-bot"
11 packages = [
12     {include = "core"},
13     {include = "client"}
14 ]
15 classifiers = [
16   "Development Status :: 4 - Beta",
17   "Topic :: Scientific/Engineering :: Artificial Intelligence",
18 ]
19 
20 [build-system]
21 requires = ["poetry-core>=1.0.0"]
22 build-backend = "poetry.core.masonry.api"
23 
24 [tool.poetry.dependencies]
25 python = ">=3.10,<3.13"
26 gitpython = "^3.1.40"
27 PyGithub = "^2.1.1"
28 langchain = ">=0.3.0,<0.4.0"
29 langchain-openai = ">=0.1.0"
30 langchain-core = ">=0.3.0,<0.4.0"
31 langchain-community = ">=0.3.0,<0.4.0"
32 python-dotenv = "^1.0.0"
33 pydantic = "^2.5.0"
34 openai = "^1.3.5"
35 pytest = "^7.4.0"
36 pathspec = ">=0.9.0"
37 toml = ">=0.10.2"
38 typing-extensions = ">=4.0.0"
39 jinja2 = ">=3.1.0,<4.0.0"
40 colorlog = ">=6.8.0,<7.0.0"
41 colorama = ">=0.4.4"
42 argparse = ">=1.4.0"
43 pyyaml = ">=6.0"
44 
45 [tool.poetry.scripts]
46 bella-issues-bot = 'client.terminal:run_workflow_from_terminal'
47 bella-file-memory = 'client.file_memory_client:main'
48 bella-github-workflows = 'client.github_workflow_generator:main'
49 
50 [tool.ruff]
51 select = ["F", "E", "W", "I001"]
52 show-fixes = false
53 target-version = "py310"
54 task-tags = ["TODO", "FIXME"]
55 extend-ignore = ["E501", "E722"]
56 
57 [tool.black]
58 target-version = ["py310"]
59 
60 [tool.ruff.isort]
61 known-first-party = []
62 known-third-party = []
63 section-order = [
64   "future",
65   "standard-library",
66   "third-party",
67   "first-party",
68   "local-folder",
69 ]
70 combine-as-imports = true
71 split-on-trailing-comma = false
72 lines-between-types = 1
73
```




# 用户需求

title：如何使用在github中使用？

